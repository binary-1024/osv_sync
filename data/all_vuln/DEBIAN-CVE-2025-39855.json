{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2025-39855.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.16.6-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "6.12.38-1",
        "6.12.41-1",
        "6.12.43-1",
        "6.12.43-1~bpo12+1",
        "6.12.48-1",
        "6.13.10-1~exp1",
        "6.13.11-1~exp1",
        "6.13.2-1~exp1",
        "6.13.3-1~exp1",
        "6.13.4-1~exp1",
        "6.13.5-1~exp1",
        "6.13.6-1~exp1",
        "6.13.7-1~exp1",
        "6.13.8-1~exp1",
        "6.13.9-1~exp1",
        "6.13~rc6-1~exp1",
        "6.13~rc7-1~exp1",
        "6.14.3-1~exp1",
        "6.14.5-1~exp1",
        "6.14.6-1~exp1",
        "6.15-1~exp1",
        "6.15.1-1~exp1",
        "6.15.2-1~exp1",
        "6.15.3-1~exp1",
        "6.15.4-1~exp1",
        "6.15.5-1~exp1",
        "6.15.6-1~exp1",
        "6.15~rc7-1~exp1",
        "6.16-1~exp1",
        "6.16.1-1~exp1",
        "6.16.3-1",
        "6.16.3-1~bpo13+1",
        "6.16.5-1",
        "6.16~rc7-1~exp1"
      ]
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  ice: fix NULL access of tx->in_use in ice_ptp_ts_irq  The E810 device has support for a \"low latency\" firmware interface to access and read the Tx timestamps. This interface does not use the standard Tx timestamp logic, due to the latency overhead of proxying sideband command requests over the firmware AdminQ.  The logic still makes use of the Tx timestamp tracking structure, ice_ptp_tx, as it uses the same \"ready\" bitmap to track which Tx timestamps complete.  Unfortunately, the ice_ptp_ts_irq() function does not check if the tracker is initialized before its first access. This results in NULL dereference or use-after-free bugs similar to the following:  [245977.278756] BUG: kernel NULL pointer dereference, address: 0000000000000000 [245977.278774] RIP: 0010:_find_first_bit+0x19/0x40 [245977.278796] Call Trace: [245977.278809]  ? ice_misc_intr+0x364/0x380 [ice]  This can occur if a Tx timestamp interrupt races with the driver reset logic.  Fix this by only checking the in_use bitmap (and other fields) if the tracker is marked as initialized. The reset flow will clear the init field under lock before it tears the tracker down, thus preventing any use-after-free or NULL access.",
  "id": "DEBIAN-CVE-2025-39855",
  "modified": "2025-09-25T04:45:17.836475Z",
  "published": "2025-09-19T16:15:44Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2025-39855"
    }
  ],
  "schema_version": "1.7.3",
  "upstream": [
    "CVE-2025-39855"
  ]
}