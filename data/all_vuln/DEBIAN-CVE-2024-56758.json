{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56758.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:12",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.147-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "6.1.106-1",
        "6.1.106-2",
        "6.1.106-3",
        "6.1.112-1",
        "6.1.115-1",
        "6.1.119-1",
        "6.1.123-1",
        "6.1.124-1",
        "6.1.128-1",
        "6.1.129-1",
        "6.1.133-1",
        "6.1.135-1",
        "6.1.137-1",
        "6.1.139-1",
        "6.1.140-1",
        "6.1.27-1",
        "6.1.37-1",
        "6.1.38-1",
        "6.1.38-2",
        "6.1.38-2~bpo11+1",
        "6.1.38-3",
        "6.1.38-4",
        "6.1.38-4~bpo11+1",
        "6.1.52-1",
        "6.1.55-1",
        "6.1.55-1~bpo11+1",
        "6.1.64-1",
        "6.1.66-1",
        "6.1.67-1",
        "6.1.69-1",
        "6.1.69-1~bpo11+1",
        "6.1.76-1",
        "6.1.76-1~bpo11+1",
        "6.1.82-1",
        "6.1.85-1",
        "6.1.90-1",
        "6.1.90-1~bpo11+1",
        "6.1.94-1",
        "6.1.94-1~bpo11+1",
        "6.1.98-1",
        "6.1.99-1"
      ]
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56758.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.8-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56758.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.8-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56758.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:11",
        "name": "linux-6.1",
        "purl": "pkg:deb/debian/linux-6.1?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.153-1~deb11u1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "6.1.106-3~deb11u1",
        "6.1.106-3~deb11u2",
        "6.1.106-3~deb11u3",
        "6.1.112-1~deb11u1",
        "6.1.119-1~deb11u1",
        "6.1.128-1~deb11u1",
        "6.1.129-1~deb11u1",
        "6.1.137-1~deb11u1",
        "6.1.140-1~deb11u1",
        "6.1.147-1~deb11u1",
        "6.1.148-1~deb11u1"
      ]
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: check folio mapping after unlock in relocate_one_folio()  When we call btrfs_read_folio() to bring a folio uptodate, we unlock the folio. The result of that is that a different thread can modify the mapping (like remove it with invalidate) before we call folio_lock(). This results in an invalid page and we need to try again.  In particular, if we are relocating concurrently with aborting a transaction, this can result in a crash like the following:    BUG: kernel NULL pointer dereference, address: 0000000000000000   PGD 0 P4D 0   Oops: 0000 [#1] SMP   CPU: 76 PID: 1411631 Comm: kworker/u322:5   Workqueue: events_unbound btrfs_reclaim_bgs_work   RIP: 0010:set_page_extent_mapped+0x20/0xb0   RSP: 0018:ffffc900516a7be8 EFLAGS: 00010246   RAX: ffffea009e851d08 RBX: ffffea009e0b1880 RCX: 0000000000000000   RDX: 0000000000000000 RSI: ffffc900516a7b90 RDI: ffffea009e0b1880   RBP: 0000000003573000 R08: 0000000000000001 R09: ffff88c07fd2f3f0   R10: 0000000000000000 R11: 0000194754b575be R12: 0000000003572000   R13: 0000000003572fff R14: 0000000000100cca R15: 0000000005582fff   FS:  0000000000000000(0000) GS:ffff88c07fd00000(0000) knlGS:0000000000000000   CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033   CR2: 0000000000000000 CR3: 000000407d00f002 CR4: 00000000007706f0   DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000   DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400   PKRU: 55555554   Call Trace:   <TASK>   ? __die+0x78/0xc0   ? page_fault_oops+0x2a8/0x3a0   ? __switch_to+0x133/0x530   ? wq_worker_running+0xa/0x40   ? exc_page_fault+0x63/0x130   ? asm_exc_page_fault+0x22/0x30   ? set_page_extent_mapped+0x20/0xb0   relocate_file_extent_cluster+0x1a7/0x940   relocate_data_extent+0xaf/0x120   relocate_block_group+0x20f/0x480   btrfs_relocate_block_group+0x152/0x320   btrfs_relocate_chunk+0x3d/0x120   btrfs_reclaim_bgs_work+0x2ae/0x4e0   process_scheduled_works+0x184/0x370   worker_thread+0xc6/0x3e0   ? blk_add_timer+0xb0/0xb0   kthread+0xae/0xe0   ? flush_tlb_kernel_range+0x90/0x90   ret_from_fork+0x2f/0x40   ? flush_tlb_kernel_range+0x90/0x90   ret_from_fork_asm+0x11/0x20   </TASK>  This occurs because cleanup_one_transaction() calls destroy_delalloc_inodes() which calls invalidate_inode_pages2() which takes the folio_lock before setting mapping to NULL. We fail to check this, and subsequently call set_extent_mapping(), which assumes that mapping != NULL (in fact it asserts that in debug mode)  Note that the \"fixes\" patch here is not the one that introduced the race (the very first iteration of this code from 2009) but a more recent change that made this particular crash happen in practice.",
  "id": "DEBIAN-CVE-2024-56758",
  "modified": "2025-10-13T11:19:14.999544Z",
  "published": "2025-01-06T17:15:40Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2024-56758"
    }
  ],
  "schema_version": "1.7.3",
  "severity": [
    {
      "score": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "type": "CVSS_V3"
    }
  ],
  "upstream": [
    "CVE-2024-56758"
  ]
}