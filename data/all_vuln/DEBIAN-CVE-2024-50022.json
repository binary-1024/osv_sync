{"schema_version":"1.7.3","id":"DEBIAN-CVE-2024-50022","published":"2024-10-21T20:15:15Z","modified":"2025-09-30T05:19:43.580468Z","upstream":["CVE-2024-50022"],"details":"In the Linux kernel, the following vulnerability has been resolved:  device-dax: correct pgoff align in dax_set_mapping()  pgoff should be aligned using ALIGN_DOWN() instead of ALIGN().  Otherwise, vmf->address not aligned to fault_size will be aligned to the next alignment, that can result in memory failure getting the wrong address.  It's a subtle situation that only can be observed in page_mapped_in_vma() after the page is page fault handled by dev_dax_huge_fault.  Generally, there is little chance to perform page_mapped_in_vma in dev-dax's page unless in specific error injection to the dax device to trigger an MCE - memory-failure.  In that case, page_mapped_in_vma() will be triggered to determine which task is accessing the failure address and kill that task in the end.   We used self-developed dax device (which is 2M aligned mapping) , to perform error injection to random address.  It turned out that error injected to non-2M-aligned address was causing endless MCE until panic. Because page_mapped_in_vma() kept resulting wrong address and the task accessing the failure address was never killed properly:   [ 3783.719419] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3784.049006] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3784.049190] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3784.448042] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3784.448186] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3784.792026] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3784.792179] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3785.162502] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3785.162633] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3785.461116] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3785.461247] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3785.764730] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3785.764859] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3786.042128] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3786.042259] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3786.464293] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3786.464423] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3786.818090] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3786.818217] Memory failure: 0x200c9742: recovery action for dax page:  Recovered [ 3787.085297] mce: Uncorrected hardware memory error in user-access at  200c9742380 [ 3787.085424] Memory failure: 0x200c9742: recovery action for dax page:  Recovered  It took us several weeks to pinpoint this problem,Â  but we eventually used bpftrace to trace the page fault and mce address and successfully identified the issue.   Joao added:  ; Likely we never reproduce in production because we always pin : device-dax regions in the region align they provide (Qemu does : similarly with prealloc in hugetlb/file backed memory).  I think this : bug requires that we touch *unpinned* device-dax regions unaligned to : the device-dax selected alignment (page size i.e.  4K/2M/1G)","affected":[{"package":{"name":"linux","ecosystem":"Debian:12","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.1.115-1"}]}],"versions":["6.1.106-1","6.1.106-2","6.1.106-3","6.1.112-1","6.1.27-1","6.1.37-1","6.1.38-1","6.1.38-2","6.1.38-2~bpo11+1","6.1.38-3","6.1.38-4","6.1.38-4~bpo11+1","6.1.52-1","6.1.55-1","6.1.55-1~bpo11+1","6.1.64-1","6.1.66-1","6.1.67-1","6.1.69-1","6.1.69-1~bpo11+1","6.1.76-1","6.1.76-1~bpo11+1","6.1.82-1","6.1.85-1","6.1.90-1","6.1.90-1~bpo11+1","6.1.94-1","6.1.94-1~bpo11+1","6.1.98-1","6.1.99-1"],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-50022.json"}},{"package":{"name":"linux","ecosystem":"Debian:13","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.11.4-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-50022.json"}},{"package":{"name":"linux","ecosystem":"Debian:14","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.11.4-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-50022.json"}},{"package":{"name":"linux-6.1","ecosystem":"Debian:11","purl":"pkg:deb/debian/linux-6.1?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.1.119-1~deb11u1"}]}],"versions":["6.1.106-3~deb11u1","6.1.106-3~deb11u2","6.1.106-3~deb11u3","6.1.112-1~deb11u1"],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-50022.json"}}],"references":[{"type":"ADVISORY","url":"https://security-tracker.debian.org/tracker/CVE-2024-50022"}],"severity":[{"type":"CVSS_V3","score":"CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"}]}