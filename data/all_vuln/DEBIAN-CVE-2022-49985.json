{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-49985.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:11",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "5.10.140-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "5.10.103-1",
        "5.10.103-1~bpo10+1",
        "5.10.106-1",
        "5.10.113-1",
        "5.10.120-1",
        "5.10.120-1~bpo10+1",
        "5.10.127-1",
        "5.10.127-2",
        "5.10.127-2~bpo10+1",
        "5.10.136-1",
        "5.10.46-4",
        "5.10.46-5",
        "5.10.70-1",
        "5.10.70-1~bpo10+1",
        "5.10.84-1",
        "5.10.92-1",
        "5.10.92-1~bpo10+1",
        "5.10.92-2"
      ]
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-49985.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:12",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.0.2-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-49985.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.0.2-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-49985.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.0.2-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Don't use tnum_range on array range checking for poke descriptors  Hsin-Wei reported a KASAN splat triggered by their BPF runtime fuzzer which is based on a customized syzkaller:    BUG: KASAN: slab-out-of-bounds in bpf_int_jit_compile+0x1257/0x13f0   Read of size 8 at addr ffff888004e90b58 by task syz-executor.0/1489   CPU: 1 PID: 1489 Comm: syz-executor.0 Not tainted 5.19.0 #1   Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS   1.13.0-1ubuntu1.1 04/01/2014   Call Trace:    <TASK>    dump_stack_lvl+0x9c/0xc9    print_address_description.constprop.0+0x1f/0x1f0    ? bpf_int_jit_compile+0x1257/0x13f0    kasan_report.cold+0xeb/0x197    ? kvmalloc_node+0x170/0x200    ? bpf_int_jit_compile+0x1257/0x13f0    bpf_int_jit_compile+0x1257/0x13f0    ? arch_prepare_bpf_dispatcher+0xd0/0xd0    ? rcu_read_lock_sched_held+0x43/0x70    bpf_prog_select_runtime+0x3e8/0x640    ? bpf_obj_name_cpy+0x149/0x1b0    bpf_prog_load+0x102f/0x2220    ? __bpf_prog_put.constprop.0+0x220/0x220    ? find_held_lock+0x2c/0x110    ? __might_fault+0xd6/0x180    ? lock_downgrade+0x6e0/0x6e0    ? lock_is_held_type+0xa6/0x120    ? __might_fault+0x147/0x180    __sys_bpf+0x137b/0x6070    ? bpf_perf_link_attach+0x530/0x530    ? new_sync_read+0x600/0x600    ? __fget_files+0x255/0x450    ? lock_downgrade+0x6e0/0x6e0    ? fput+0x30/0x1a0    ? ksys_write+0x1a8/0x260    __x64_sys_bpf+0x7a/0xc0    ? syscall_enter_from_user_mode+0x21/0x70    do_syscall_64+0x3b/0x90    entry_SYSCALL_64_after_hwframe+0x63/0xcd   RIP: 0033:0x7f917c4e2c2d  The problem here is that a range of tnum_range(0, map->max_entries - 1) has limited ability to represent the concrete tight range with the tnum as the set of resulting states from value + mask can result in a superset of the actual intended range, and as such a tnum_in(range, reg->var_off) check may yield true when it shouldn't, for example tnum_range(0, 2) would result in 00XX -> v = 0000, m = 0011 such that the intended set of {0, 1, 2} is here represented by a less precise superset of {0, 1, 2, 3}. As the register is known const scalar, really just use the concrete reg->var_off.value for the upper index check.",
  "id": "DEBIAN-CVE-2022-49985",
  "modified": "2025-09-24T00:57:07.949251Z",
  "published": "2025-06-18T11:15:26Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2022-49985"
    }
  ],
  "schema_version": "1.7.3"
}