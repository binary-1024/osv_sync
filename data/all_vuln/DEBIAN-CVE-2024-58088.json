{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-58088.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.17-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-58088.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.17-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix deadlock when freeing cgroup storage  The following commit bc235cdb423a (\"bpf: Prevent deadlock from recursive bpf_task_storage_[get|delete]\") first introduced deadlock prevention for fentry/fexit programs attaching on bpf_task_storage helpers. That commit also employed the logic in map free path in its v6 version.  Later bpf_cgrp_storage was first introduced in c4bcfb38a95e (\"bpf: Implement cgroup storage available to non-cgroup-attached bpf progs\") which faces the same issue as bpf_task_storage, instead of its busy counter, NULL was passed to bpf_local_storage_map_free() which opened a window to cause deadlock:  \t<TASK> \t\t(acquiring local_storage->lock) \t_raw_spin_lock_irqsave+0x3d/0x50 \tbpf_local_storage_update+0xd1/0x460 \tbpf_cgrp_storage_get+0x109/0x130 \tbpf_prog_a4d4a370ba857314_cgrp_ptr+0x139/0x170 \t? __bpf_prog_enter_recur+0x16/0x80 \tbpf_trampoline_6442485186+0x43/0xa4 \tcgroup_storage_ptr+0x9/0x20 \t\t(holding local_storage->lock) \tbpf_selem_unlink_storage_nolock.constprop.0+0x135/0x160 \tbpf_selem_unlink_storage+0x6f/0x110 \tbpf_local_storage_map_free+0xa2/0x110 \tbpf_map_free_deferred+0x5b/0x90 \tprocess_one_work+0x17c/0x390 \tworker_thread+0x251/0x360 \tkthread+0xd2/0x100 \tret_from_fork+0x34/0x50 \tret_from_fork_asm+0x1a/0x30 \t</TASK>  Progs:  - A: SEC(\"fentry/cgroup_storage_ptr\")    - cgid (BPF_MAP_TYPE_HASH) \tRecord the id of the cgroup the current task belonging \tto in this hash map, using the address of the cgroup \tas the map key.    - cgrpa (BPF_MAP_TYPE_CGRP_STORAGE) \tIf current task is a kworker, lookup the above hash \tmap using function parameter @owner as the key to get \tits corresponding cgroup id which is then used to get \ta trusted pointer to the cgroup through \tbpf_cgroup_from_id(). This trusted pointer can then \tbe passed to bpf_cgrp_storage_get() to finally trigger \tthe deadlock issue.  - B: SEC(\"tp_btf/sys_enter\")    - cgrpb (BPF_MAP_TYPE_CGRP_STORAGE) \tThe only purpose of this prog is to fill Prog A's \thash map by calling bpf_cgrp_storage_get() for as \tmany userspace tasks as possible.  Steps to reproduce:  - Run A;  - while (true) { Run B; Destroy B; }  Fix this issue by passing its busy counter to the free procedure so it can be properly incremented before storage/smap locking.",
  "id": "DEBIAN-CVE-2024-58088",
  "modified": "2025-09-24T00:03:55Z",
  "published": "2025-03-12T10:15:16Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2024-58088"
    }
  ],
  "schema_version": "1.7.3"
}