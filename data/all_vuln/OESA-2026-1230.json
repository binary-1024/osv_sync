{"schema_version":"1.7.3","id":"OESA-2026-1230","published":"2026-01-23T12:23:57Z","modified":"2026-01-23T12:45:00.766138Z","upstream":["CVE-2024-58241","CVE-2025-37928","CVE-2025-37985","CVE-2025-38008","CVE-2025-38436","CVE-2025-39673","CVE-2025-39835","CVE-2025-39925"],"summary":"kernel security update","details":"The Linux Kernel, the operating system core itself.\r\n\r\nSecurity Fix(es):\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nBluetooth: hci_core: Disable works on hci_unregister_dev\n\nThis make use of disable_work_* on hci_unregister_dev since the hci_dev is\nabout to be freed new submissions are not disarable.(CVE-2024-58241)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ndm-bufio: don&apos;t schedule in atomic context\n\nA BUG was reported as below when CONFIG_DEBUG_ATOMIC_SLEEP and\ntry_verify_in_tasklet are enabled.\n[  129.444685][  T934] BUG: sleeping function called from invalid context at drivers/md/dm-bufio.c:2421\n[  129.444723][  T934] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 934, name: kworker/1:4\n[  129.444740][  T934] preempt_count: 201, expected: 0\n[  129.444756][  T934] RCU nest depth: 0, expected: 0\n[  129.444781][  T934] Preemption disabled at:\n[  129.444789][  T934] [&lt;ffffffd816231900&gt;] shrink_work+0x21c/0x248\n[  129.445167][  T934] kernel BUG at kernel/sched/walt/walt_debug.c:16!\n[  129.445183][  T934] Internal error: Oops - BUG: 00000000f2000800 [#1] PREEMPT SMP\n[  129.445204][  T934] Skip md ftrace buffer dump for: 0x1609e0\n[  129.447348][  T934] CPU: 1 PID: 934 Comm: kworker/1:4 Tainted: G        W  OE      6.6.56-android15-8-o-g6f82312b30b9-debug #1 1400000003000000474e5500b3187743670464e8\n[  129.447362][  T934] Hardware name: Qualcomm Technologies, Inc. Parrot QRD, Alpha-M (DT)\n[  129.447373][  T934] Workqueue: dm_bufio_cache shrink_work\n[  129.447394][  T934] pstate: 60400005 (nZCv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)\n[  129.447406][  T934] pc : android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug]\n[  129.447435][  T934] lr : __traceiter_android_rvh_schedule_bug+0x44/0x6c\n[  129.447451][  T934] sp : ffffffc0843dbc90\n[  129.447459][  T934] x29: ffffffc0843dbc90 x28: ffffffffffffffff x27: 0000000000000c8b\n[  129.447479][  T934] x26: 0000000000000040 x25: ffffff804b3d6260 x24: ffffffd816232b68\n[  129.447497][  T934] x23: ffffff805171c5b4 x22: 0000000000000000 x21: ffffffd816231900\n[  129.447517][  T934] x20: ffffff80306ba898 x19: 0000000000000000 x18: ffffffc084159030\n[  129.447535][  T934] x17: 00000000d2b5dd1f x16: 00000000d2b5dd1f x15: ffffffd816720358\n[  129.447554][  T934] x14: 0000000000000004 x13: ffffff89ef978000 x12: 0000000000000003\n[  129.447572][  T934] x11: ffffffd817a823c4 x10: 0000000000000202 x9 : 7e779c5735de9400\n[  129.447591][  T934] x8 : ffffffd81560d004 x7 : 205b5d3938373434 x6 : ffffffd8167397c8\n[  129.447610][  T934] x5 : 0000000000000000 x4 : 0000000000000001 x3 : ffffffc0843db9e0\n[  129.447629][  T934] x2 : 0000000000002f15 x1 : 0000000000000000 x0 : 0000000000000000\n[  129.447647][  T934] Call trace:\n[  129.447655][  T934]  android_rvh_schedule_bug+0x0/0x8 [sched_walt_debug 1400000003000000474e550080cce8a8a78606b6]\n[  129.447681][  T934]  __might_resched+0x190/0x1a8\n[  129.447694][  T934]  shrink_work+0x180/0x248\n[  129.447706][  T934]  process_one_work+0x260/0x624\n[  129.447718][  T934]  worker_thread+0x28c/0x454\n[  129.447729][  T934]  kthread+0x118/0x158\n[  129.447742][  T934]  ret_from_fork+0x10/0x20\n[  129.447761][  T934] Code: ???????? ???????? ???????? d2b5dd1f (d4210000)\n[  129.447772][  T934] ---[ end trace 0000000000000000 ]---\n\ndm_bufio_lock will call spin_lock_bh when try_verify_in_tasklet\nis enabled, and __scan will be called in atomic context.(CVE-2025-37928)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nUSB: wdm: close race between wdm_open and wdm_wwan_port_stop\n\nClearing WDM_WWAN_IN_USE must be the last action or\nwe can open a chardev whose URBs are still poisoned(CVE-2025-37985)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nmm/page_alloc: fix race condition in unaccepted memory handling\n\nThe page allocator tracks the number of zones that have unaccepted memory\nusing static_branch_enc/dec() and uses that static branch in hot paths to\ndetermine if it needs to deal with unaccepted memory.\n\nBorislav and Thomas pointed out that the tracking is racy: operations on\nstatic_branch are not serialized against adding/removing unaccepted pages\nto/from the zone.\n\nSanity checks inside static_branch machinery detects it:\n\nWARNING: CPU: 0 PID: 10 at kernel/jump_label.c:276 __static_key_slow_dec_cpuslocked+0x8e/0xa0\n\nThe comment around the WARN() explains the problem:\n\n\t/*\n\t * Warn about the &apos;-1&apos; case though; since that means a\n\t * decrement is concurrent with a first (0-&gt;1) increment. IOW\n\t * people are trying to disable something that wasn&apos;t yet fully\n\t * enabled. This suggests an ordering problem on the user side.\n\t */\n\nThe effect of this static_branch optimization is only visible on\nmicrobenchmark.\n\nInstead of adding more complexity around it, remove it altogether.(CVE-2025-38008)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ndrm/scheduler: signal scheduled fence when kill job\n\nWhen an entity from application B is killed, drm_sched_entity_kill()\nremoves all jobs belonging to that entity through\ndrm_sched_entity_kill_jobs_work(). If application A&apos;s job depends on a\nscheduled fence from application B&apos;s job, and that fence is not properly\nsignaled during the killing process, application A&apos;s dependency cannot be\ncleared.\n\nThis leads to application A hanging indefinitely while waiting for a\ndependency that will never be resolved. Fix this issue by ensuring that\nscheduled fences are properly signaled when an entity is killed, allowing\ndependent applications to continue execution.(CVE-2025-38436)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nppp: fix race conditions in ppp_fill_forward_path\n\nppp_fill_forward_path() has two race conditions:\n\n1. The ppp-&gt;channels list can change between list_empty() and\n   list_first_entry(), as ppp_lock() is not held. If the only channel\n   is deleted in ppp_disconnect_channel(), list_first_entry() may\n   access an empty head or a freed entry, and trigger a panic.\n\n2. pch-&gt;chan can be NULL. When ppp_unregister_channel() is called,\n   pch-&gt;chan is set to NULL before pch is removed from ppp-&gt;channels.\n\nFix these by using a lockless RCU approach:\n- Use list_first_or_null_rcu() to safely test and access the first list\n  entry.\n- Convert list modifications on ppp-&gt;channels to their RCU variants and\n  add synchronize_net() after removal.\n- Check for a NULL pch-&gt;chan before dereferencing it.(CVE-2025-39673)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\nxfs: do not propagate ENODATA disk errors into xattr code\n\nENODATA (aka ENOATTR) has a very specific meaning in the xfs xattr code;\nnamely, that the requested attribute name could not be found.\n\nHowever, a medium error from disk may also return ENODATA. At best,\nthis medium error may escape to userspace as &quot;attribute not found&quot;\nwhen in fact it&apos;s an IO (disk) error.\n\nAt worst, we may oops in xfs_attr_leaf_get() when we do:\n\n\terror = xfs_attr_leaf_hasname(args, &amp;bp);\n\tif (error == -ENOATTR)  {\n\t\txfs_trans_brelse(args-&gt;trans, bp);\n\t\treturn error;\n\t}\n\nbecause an ENODATA/ENOATTR error from disk leaves us with a null bp,\nand the xfs_trans_brelse will then null-deref it.\n\nAs discussed on the list, we really need to modify the lower level\nIO functions to trap all disk errors and ensure that we don&apos;t let\nunique errors like this leak up into higher xfs functions - many\nlike this should be remapped to EIO.\n\nHowever, this patch directly addresses a reported bug in the xattr\ncode, and should be safe to backport to stable kernels. A larger-scope\npatch to handle more unique errors at lower levels can follow later.\n\n(Note, prior to 07120f1abdff we did not oops, but we did return the\nwrong error code to userspace.)(CVE-2025-39835)\n\nIn the Linux kernel, the following vulnerability has been resolved:\n\ncan: j1939: implement NETDEV_UNREGISTER notification handler\n\nsyzbot is reporting\n\n  unregister_netdevice: waiting for vcan0 to become free. Usage count = 2\n\nproblem, for j1939 protocol did not have NETDEV_UNREGISTER notification\nhandler for undoing changes made by j1939_sk_bind().\n\nCommit 25fe97cb7620 (&quot;can: j1939: move j1939_priv_put() into sk_destruct\ncallback&quot;) expects that a call to j1939_priv_put() can be unconditionally\ndelayed until j1939_sk_sock_destruct() is called. But we need to call\nj1939_priv_put() against an extra ref held by j1939_sk_bind() call\n(as a part of undoing changes made by j1939_sk_bind()) as soon as\nNETDEV_UNREGISTER notification fires (i.e. before j1939_sk_sock_destruct()\nis called via j1939_sk_release()). Otherwise, the extra ref on &quot;struct\nj1939_priv&quot; held by j1939_sk_bind() call prevents &quot;struct net_device&quot; from\ndropping the usage count to 1; making it impossible for\nunregister_netdevice() to continue.\n\n[mkl: remove space in front of label](CVE-2025-39925)","affected":[{"package":{"name":"kernel","ecosystem":"openEuler:24.03-LTS-SP2","purl":"pkg:rpm/openEuler/kernel&distro=openEuler-24.03-LTS-SP2"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.6.0-135.0.0.129.oe2403sp2"}]}],"ecosystem_specific":{"aarch64":["bpftool-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","bpftool-debuginfo-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-debuginfo-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-debugsource-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-devel-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-extra-modules-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-headers-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-source-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-tools-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-tools-debuginfo-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","kernel-tools-devel-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","perf-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","perf-debuginfo-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","python3-perf-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm","python3-perf-debuginfo-6.6.0-135.0.0.129.oe2403sp2.aarch64.rpm"],"src":["kernel-6.6.0-135.0.0.129.oe2403sp2.src.rpm"],"x86_64":["bpftool-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","bpftool-debuginfo-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-debuginfo-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-debugsource-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-devel-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-extra-modules-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-headers-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-source-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-tools-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-tools-debuginfo-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","kernel-tools-devel-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","perf-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","perf-debuginfo-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","python3-perf-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm","python3-perf-debuginfo-6.6.0-135.0.0.129.oe2403sp2.x86_64.rpm"]},"database_specific":{"source":"https://repo.openeuler.org/security/data/osv/OESA-2026-1230.json"}}],"references":[{"type":"ADVISORY","url":"https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2026-1230"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-58241"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-37928"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-37985"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-38008"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-38436"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-39673"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-39835"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2025-39925"}],"database_specific":{"severity":"High"}}