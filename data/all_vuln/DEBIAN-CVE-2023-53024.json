{"schema_version":"1.7.3","id":"DEBIAN-CVE-2023-53024","published":"2025-03-27T17:15:51.980Z","modified":"2026-01-23T11:16:38.976769Z","upstream":["CVE-2023-53024"],"details":"In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix pointer-leak due to insufficient speculative store bypass mitigation  To mitigate Spectre v4, 2039f26f3aca (\"bpf: Fix leakage due to insufficient speculative store bypass mitigation\") inserts lfence instructions after 1) initializing a stack slot and 2) spilling a pointer to the stack.  However, this does not cover cases where a stack slot is first initialized with a pointer (subject to sanitization) but then overwritten with a scalar (not subject to sanitization because the slot was already initialized). In this case, the second write may be subject to speculative store bypass (SSB) creating a speculative pointer-as-scalar type confusion. This allows the program to subsequently leak the numerical pointer value using, for example, a branch-based cache side channel.  To fix this, also sanitize scalars if they write a stack slot that previously contained a pointer. Assuming that pointer-spills are only generated by LLVM on register-pressure, the performance impact on most real-world BPF programs should be small.  The following unprivileged BPF bytecode drafts a minimal exploit and the mitigation:    [...]   // r6 = 0 or 1 (skalar, unknown user input)   // r7 = accessible ptr for side channel   // r10 = frame pointer (fp), to be leaked   //   r9 = r10 # fp alias to encourage ssb   *(u64 *)(r9 - 8) = r10 // fp[-8] = ptr, to be leaked   // lfence added here because of pointer spill to stack.   //   // Ommitted: Dummy bpf_ringbuf_output() here to train alias predictor   // for no r9-r10 dependency.   //   *(u64 *)(r10 - 8) = r6 // fp[-8] = scalar, overwrites ptr   // 2039f26f3aca: no lfence added because stack slot was not STACK_INVALID,   // store may be subject to SSB   //   // fix: also add an lfence when the slot contained a ptr   //   r8 = *(u64 *)(r9 - 8)   // r8 = architecturally a scalar, speculatively a ptr   //   // leak ptr using branch-based cache side channel:   r8 &= 1 // choose bit to leak   if r8 == 0 goto SLOW // no mispredict   // architecturally dead code if input r6 is 0,   // only executes speculatively iff ptr bit is 1   r8 = *(u64 *)(r7 + 0) # encode bit in cache (0: slow, 1: fast) SLOW:   [...]  After running this, the program can time the access to *(r7 + 0) to determine whether the chosen pointer bit was 0 or 1. Repeat this 64 times to recover the whole address on amd64.  In summary, sanitization can only be skipped if one scalar is overwritten with another scalar. Scalar-confusion due to speculative store bypass can not lead to invalid accesses because the pointer bounds deducted during verification are enforced using branchless logic. See 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\") for details.  Do not make the mitigation depend on !env->allow_{uninit_stack,ptr_leaks} because speculative leaks are likely unexpected if these were enabled. For example, leaking the address to a protected log file may be acceptable while disabling the mitigation might unintentionally leak the address into the cached-state of a map that is accessible to unprivileged processes.","affected":[{"package":{"name":"linux","ecosystem":"Debian:11","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"5.10.178-1"}]}],"versions":["5.10.103-1","5.10.103-1~bpo10+1","5.10.106-1","5.10.113-1","5.10.120-1","5.10.120-1~bpo10+1","5.10.127-1","5.10.127-2","5.10.127-2~bpo10+1","5.10.136-1","5.10.140-1","5.10.148-1","5.10.149-1","5.10.149-2","5.10.158-1","5.10.158-2","5.10.162-1","5.10.46-4","5.10.46-5","5.10.70-1","5.10.70-1~bpo10+1","5.10.84-1","5.10.92-1","5.10.92-1~bpo10+1","5.10.92-2"],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"}},{"package":{"name":"linux","ecosystem":"Debian:12","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.1.11-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"}},{"package":{"name":"linux","ecosystem":"Debian:13","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.1.11-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"}},{"package":{"name":"linux","ecosystem":"Debian:14","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.1.11-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"}}],"references":[{"type":"ADVISORY","url":"https://security-tracker.debian.org/tracker/CVE-2023-53024"}],"severity":[{"type":"CVSS_V3","score":"CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H"}]}