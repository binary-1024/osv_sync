{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:11",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "5.10.178-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "5.10.103-1",
        "5.10.103-1~bpo10+1",
        "5.10.106-1",
        "5.10.113-1",
        "5.10.120-1",
        "5.10.120-1~bpo10+1",
        "5.10.127-1",
        "5.10.127-2",
        "5.10.127-2~bpo10+1",
        "5.10.136-1",
        "5.10.140-1",
        "5.10.148-1",
        "5.10.149-1",
        "5.10.149-2",
        "5.10.158-1",
        "5.10.158-2",
        "5.10.162-1",
        "5.10.46-4",
        "5.10.46-5",
        "5.10.70-1",
        "5.10.70-1~bpo10+1",
        "5.10.84-1",
        "5.10.92-1",
        "5.10.92-1~bpo10+1",
        "5.10.92-2"
      ]
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:12",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.11-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.11-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53024.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.11-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  bpf: Fix pointer-leak due to insufficient speculative store bypass mitigation  To mitigate Spectre v4, 2039f26f3aca (\"bpf: Fix leakage due to insufficient speculative store bypass mitigation\") inserts lfence instructions after 1) initializing a stack slot and 2) spilling a pointer to the stack.  However, this does not cover cases where a stack slot is first initialized with a pointer (subject to sanitization) but then overwritten with a scalar (not subject to sanitization because the slot was already initialized). In this case, the second write may be subject to speculative store bypass (SSB) creating a speculative pointer-as-scalar type confusion. This allows the program to subsequently leak the numerical pointer value using, for example, a branch-based cache side channel.  To fix this, also sanitize scalars if they write a stack slot that previously contained a pointer. Assuming that pointer-spills are only generated by LLVM on register-pressure, the performance impact on most real-world BPF programs should be small.  The following unprivileged BPF bytecode drafts a minimal exploit and the mitigation:    [...]   // r6 = 0 or 1 (skalar, unknown user input)   // r7 = accessible ptr for side channel   // r10 = frame pointer (fp), to be leaked   //   r9 = r10 # fp alias to encourage ssb   *(u64 *)(r9 - 8) = r10 // fp[-8] = ptr, to be leaked   // lfence added here because of pointer spill to stack.   //   // Ommitted: Dummy bpf_ringbuf_output() here to train alias predictor   // for no r9-r10 dependency.   //   *(u64 *)(r10 - 8) = r6 // fp[-8] = scalar, overwrites ptr   // 2039f26f3aca: no lfence added because stack slot was not STACK_INVALID,   // store may be subject to SSB   //   // fix: also add an lfence when the slot contained a ptr   //   r8 = *(u64 *)(r9 - 8)   // r8 = architecturally a scalar, speculatively a ptr   //   // leak ptr using branch-based cache side channel:   r8 &= 1 // choose bit to leak   if r8 == 0 goto SLOW // no mispredict   // architecturally dead code if input r6 is 0,   // only executes speculatively iff ptr bit is 1   r8 = *(u64 *)(r7 + 0) # encode bit in cache (0: slow, 1: fast) SLOW:   [...]  After running this, the program can time the access to *(r7 + 0) to determine whether the chosen pointer bit was 0 or 1. Repeat this 64 times to recover the whole address on amd64.  In summary, sanitization can only be skipped if one scalar is overwritten with another scalar. Scalar-confusion due to speculative store bypass can not lead to invalid accesses because the pointer bounds deducted during verification are enforced using branchless logic. See 979d63d50c0c (\"bpf: prevent out of bounds speculation on pointer arithmetic\") for details.  Do not make the mitigation depend on !env->allow_{uninit_stack,ptr_leaks} because speculative leaks are likely unexpected if these were enabled. For example, leaking the address to a protected log file may be acceptable while disabling the mitigation might unintentionally leak the address into the cached-state of a map that is accessible to unprivileged processes.",
  "id": "DEBIAN-CVE-2023-53024",
  "modified": "2025-09-25T03:44:08.612626Z",
  "published": "2025-03-27T17:15:51Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2023-53024"
    }
  ],
  "schema_version": "1.7.3",
  "upstream": [
    "CVE-2023-53024"
  ]
}