{"schema_version":"1.7.3","id":"DEBIAN-CVE-2024-56714","published":"2024-12-29T09:15:06Z","modified":"2025-10-16T09:01:22Z","upstream":["CVE-2024-56714"],"details":"In the Linux kernel, the following vulnerability has been resolved:  ionic: no double destroy workqueue  There are some FW error handling paths that can cause us to try to destroy the workqueue more than once, so let's be sure we're checking for that.  The case where this popped up was in an AER event where the handlers got called in such a way that ionic_reset_prepare() and thus ionic_dev_teardown() got called twice in a row. The second time through the workqueue was already destroyed, and destroy_workqueue() choked on the bad wq pointer.  We didn't hit this in AER handler testing before because at that time we weren't using a private workqueue.  Later we replaced the use of the system workqueue with our own private workqueue but hadn't rerun the AER handler testing since then.","affected":[{"package":{"name":"linux","ecosystem":"Debian:13","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.12.8-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56714.json"}},{"package":{"name":"linux","ecosystem":"Debian:14","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.12.8-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56714.json"}}],"references":[{"type":"ADVISORY","url":"https://security-tracker.debian.org/tracker/CVE-2024-56714"}],"severity":[{"type":"CVSS_V3","score":"CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H"}]}