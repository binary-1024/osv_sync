{"schema_version":"1.7.3","id":"DEBIAN-CVE-2023-53368","published":"2025-09-17T15:15:41Z","modified":"2025-09-30T05:18:59.804696Z","upstream":["CVE-2023-53368"],"details":"In the Linux kernel, the following vulnerability has been resolved:  tracing: Fix race issue between cpu buffer write and swap  Warning happened in rb_end_commit() at code: \tif (RB_WARN_ON(cpu_buffer, !local_read(&cpu_buffer->committing)))    WARNING: CPU: 0 PID: 139 at kernel/trace/ring_buffer.c:3142 \trb_commit+0x402/0x4a0   Call Trace:    ring_buffer_unlock_commit+0x42/0x250    trace_buffer_unlock_commit_regs+0x3b/0x250    trace_event_buffer_commit+0xe5/0x440    trace_event_buffer_reserve+0x11c/0x150    trace_event_raw_event_sched_switch+0x23c/0x2c0    __traceiter_sched_switch+0x59/0x80    __schedule+0x72b/0x1580    schedule+0x92/0x120    worker_thread+0xa0/0x6f0  It is because the race between writing event into cpu buffer and swapping cpu buffer through file per_cpu/cpu0/snapshot:    Write on CPU 0             Swap buffer by per_cpu/cpu0/snapshot on CPU 1   --------                   --------                              tracing_snapshot_write()                                [...]    ring_buffer_lock_reserve()     cpu_buffer = buffer->buffers[cpu]; // 1. Suppose find 'cpu_buffer_a';     [...]     rb_reserve_next_event()       [...]                                 ring_buffer_swap_cpu()                                  if (local_read(&cpu_buffer_a->committing))                                      goto out_dec;                                  if (local_read(&cpu_buffer_b->committing))                                      goto out_dec;                                  buffer_a->buffers[cpu] = cpu_buffer_b;                                  buffer_b->buffers[cpu] = cpu_buffer_a;                                  // 2. cpu_buffer has swapped here.        rb_start_commit(cpu_buffer);       if (unlikely(READ_ONCE(cpu_buffer->buffer)           != buffer)) { // 3. This check passed due to 'cpu_buffer->buffer'         [...]           //    has not changed here.         return NULL;       }                                  cpu_buffer_b->buffer = buffer_a;                                  cpu_buffer_a->buffer = buffer_b;                                  [...]        // 4. Reserve event from 'cpu_buffer_a'.    ring_buffer_unlock_commit()     [...]     cpu_buffer = buffer->buffers[cpu]; // 5. Now find 'cpu_buffer_b' !!!     rb_commit(cpu_buffer)       rb_end_commit()  // 6. WARN for the wrong 'committing' state !!!  Based on above analysis, we can easily reproduce by following testcase:   ``` bash   #!/bin/bash    dmesg -n 7   sysctl -w kernel.panic_on_warn=1   TR=/sys/kernel/tracing   echo 7 > ${TR}/buffer_size_kb   echo \"sched:sched_switch\" > ${TR}/set_event   while [ true ]; do           echo 1 > ${TR}/per_cpu/cpu0/snapshot   done &   while [ true ]; do           echo 1 > ${TR}/per_cpu/cpu0/snapshot   done &   while [ true ]; do           echo 1 > ${TR}/per_cpu/cpu0/snapshot   done &   ```  To fix it, IIUC, we can use smp_call_function_single() to do the swap on the target cpu where the buffer is located, so that above race would be avoided.","affected":[{"package":{"name":"linux","ecosystem":"Debian:11","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"5.10.197-1"}]}],"versions":["5.10.103-1","5.10.103-1~bpo10+1","5.10.106-1","5.10.113-1","5.10.120-1","5.10.120-1~bpo10+1","5.10.127-1","5.10.127-2","5.10.127-2~bpo10+1","5.10.136-1","5.10.140-1","5.10.148-1","5.10.149-1","5.10.149-2","5.10.158-1","5.10.158-2","5.10.162-1","5.10.178-1","5.10.178-2","5.10.178-3","5.10.179-1","5.10.179-2","5.10.179-3","5.10.179-4","5.10.179-5","5.10.191-1","5.10.46-4","5.10.46-5","5.10.70-1","5.10.70-1~bpo10+1","5.10.84-1","5.10.92-1","5.10.92-1~bpo10+1","5.10.92-2"],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53368.json"}},{"package":{"name":"linux","ecosystem":"Debian:12","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.1.55-1"}]}],"versions":["6.1.27-1","6.1.37-1","6.1.38-1","6.1.38-2","6.1.38-2~bpo11+1","6.1.38-3","6.1.38-4","6.1.38-4~bpo11+1","6.1.52-1","6.1.55-1~bpo11+1"],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53368.json"}},{"package":{"name":"linux","ecosystem":"Debian:13","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.5.3-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53368.json"}},{"package":{"name":"linux","ecosystem":"Debian:14","purl":"pkg:deb/debian/linux?arch=source"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"6.5.3-1"}]}],"ecosystem_specific":{"urgency":"not yet assigned"},"database_specific":{"source":"https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-53368.json"}}],"references":[{"type":"ADVISORY","url":"https://security-tracker.debian.org/tracker/CVE-2023-53368"}]}