{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56613.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.5-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2024-56613.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.5-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  sched/numa: fix memory leak due to the overwritten vma->numab_state  [Problem Description] When running the hackbench program of LTP, the following memory leak is reported by kmemleak.    # /opt/ltp/testcases/bin/hackbench 20 thread 1000   Running with 20*40 (== 800) tasks.    # dmesg | grep kmemleak   ...   kmemleak: 480 new suspected memory leaks (see /sys/kernel/debug/kmemleak)   kmemleak: 665 new suspected memory leaks (see /sys/kernel/debug/kmemleak)    # cat /sys/kernel/debug/kmemleak   unreferenced object 0xffff888cd8ca2c40 (size 64):     comm \"hackbench\", pid 17142, jiffies 4299780315     hex dump (first 32 bytes):       ac 74 49 00 01 00 00 00 4c 84 49 00 01 00 00 00  .tI.....L.I.....       00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................     backtrace (crc bff18fd4):       [<ffffffff81419a89>] __kmalloc_cache_noprof+0x2f9/0x3f0       [<ffffffff8113f715>] task_numa_work+0x725/0xa00       [<ffffffff8110f878>] task_work_run+0x58/0x90       [<ffffffff81ddd9f8>] syscall_exit_to_user_mode+0x1c8/0x1e0       [<ffffffff81dd78d5>] do_syscall_64+0x85/0x150       [<ffffffff81e0012b>] entry_SYSCALL_64_after_hwframe+0x76/0x7e   ...  This issue can be consistently reproduced on three different servers:   * a 448-core server   * a 256-core server   * a 192-core server  [Root Cause] Since multiple threads are created by the hackbench program (along with the command argument 'thread'), a shared vma might be accessed by two or more cores simultaneously. When two or more cores observe that vma->numab_state is NULL at the same time, vma->numab_state will be overwritten.  Although current code ensures that only one thread scans the VMAs in a single 'numa_scan_period', there might be a chance for another thread to enter in the next 'numa_scan_period' while we have not gotten till numab_state allocation [1].  Note that the command `/opt/ltp/testcases/bin/hackbench 50 process 1000` cannot the reproduce the issue. It is verified with 200+ test runs.  [Solution] Use the cmpxchg atomic operation to ensure that only one thread executes the vma->numab_state assignment.  [1] https://lore.kernel.org/lkml/1794be3c-358c-4cdc-a43d-a1f841d91ef7@amd.com/",
  "id": "DEBIAN-CVE-2024-56613",
  "modified": "2025-09-30T03:54:22Z",
  "published": "2024-12-27T15:15:20Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2024-56613"
    }
  ],
  "schema_version": "1.7.3",
  "severity": [
    {
      "score": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
      "type": "CVSS_V3"
    }
  ],
  "upstream": [
    "CVE-2024-56613"
  ]
}