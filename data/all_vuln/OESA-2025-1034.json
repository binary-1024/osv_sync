{
  "affected": [
    {
      "database_specific": {
        "source": "https://repo.openeuler.org/security/data/osv/OESA-2025-1034.json"
      },
      "ecosystem_specific": {
        "aarch64": [
          "bpftool-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "bpftool-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-debugsource-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-devel-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-source-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-tools-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-tools-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "kernel-tools-devel-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "perf-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "perf-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "python2-perf-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "python2-perf-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "python3-perf-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm",
          "python3-perf-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.aarch64.rpm"
        ],
        "src": [
          "kernel-4.19.90-2501.1.0.0311.oe2003sp4.src.rpm"
        ],
        "x86_64": [
          "bpftool-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "bpftool-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-debugsource-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-devel-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-source-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-tools-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-tools-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "kernel-tools-devel-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "perf-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "perf-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "python2-perf-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "python2-perf-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "python3-perf-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm",
          "python3-perf-debuginfo-4.19.90-2501.1.0.0311.oe2003sp4.x86_64.rpm"
        ]
      },
      "package": {
        "ecosystem": "openEuler:20.03-LTS-SP4",
        "name": "kernel",
        "purl": "pkg:rpm/openEuler/kernel&distro=openEuler-20.03-LTS-SP4"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "4.19.90-2501.1.0.0311.oe2003sp4"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "database_specific": {
    "severity": "High"
  },
  "details": "The Linux Kernel, the operating system core itself.\r\n\r\nSecurity Fix(es):\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  sh: cpuinfo: Fix a warning for CONFIG_CPUMASK_OFFSTACK  When CONFIG_CPUMASK_OFFSTACK and CONFIG_DEBUG_PER_CPU_MAPS are selected, cpu_max_bits_warn() generates a runtime warning similar as below when showing /proc/cpuinfo. Fix this by using nr_cpu_ids (the runtime limit) instead of NR_CPUS to iterate CPUs.  [    3.052463] ------------[ cut here ]------------ [    3.059679] WARNING: CPU: 3 PID: 1 at include/linux/cpumask.h:108 show_cpuinfo+0x5e8/0x5f0 [    3.070072] Modules linked in: efivarfs autofs4 [    3.076257] CPU: 0 PID: 1 Comm: systemd Not tainted 5.19-rc5+ #1052 [    3.099465] Stack : 9000000100157b08 9000000000f18530 9000000000cf846c 9000000100154000 [    3.109127]         9000000100157a50 0000000000000000 9000000100157a58 9000000000ef7430 [    3.118774]         90000001001578e8 0000000000000040 0000000000000020 ffffffffffffffff [    3.128412]         0000000000aaaaaa 1ab25f00eec96a37 900000010021de80 900000000101c890 [    3.138056]         0000000000000000 0000000000000000 0000000000000000 0000000000aaaaaa [    3.147711]         ffff8000339dc220 0000000000000001 0000000006ab4000 0000000000000000 [    3.157364]         900000000101c998 0000000000000004 9000000000ef7430 0000000000000000 [    3.167012]         0000000000000009 000000000000006c 0000000000000000 0000000000000000 [    3.176641]         9000000000d3de08 9000000001639390 90000000002086d8 00007ffff0080286 [    3.186260]         00000000000000b0 0000000000000004 0000000000000000 0000000000071c1c [    3.195868]         ... [    3.199917] Call Trace: [    3.203941] [&lt;90000000002086d8&gt;] show_stack+0x38/0x14c [    3.210666] [&lt;9000000000cf846c&gt;] dump_stack_lvl+0x60/0x88 [    3.217625] [&lt;900000000023d268&gt;] __warn+0xd0/0x100 [    3.223958] [&lt;9000000000cf3c90&gt;] warn_slowpath_fmt+0x7c/0xcc [    3.231150] [&lt;9000000000210220&gt;] show_cpuinfo+0x5e8/0x5f0 [    3.238080] [&lt;90000000004f578c&gt;] seq_read_iter+0x354/0x4b4 [    3.245098] [&lt;90000000004c2e90&gt;] new_sync_read+0x17c/0x1c4 [    3.252114] [&lt;90000000004c5174&gt;] vfs_read+0x138/0x1d0 [    3.258694] [&lt;90000000004c55f8&gt;] ksys_read+0x70/0x100 [    3.265265] [&lt;9000000000cfde9c&gt;] do_syscall+0x7c/0x94 [    3.271820] [&lt;9000000000202fe4&gt;] handle_syscall+0xc4/0x160 [    3.281824] ---[ end trace 8b484262b4b8c24c ]---(CVE-2022-49034)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  media: s5p_cec: limit msg.len to CEC_MAX_MSG_SIZE  I expect that the hardware will have limited this to 16, but just in case it hasn&apos;t, check for this corner case.(CVE-2022-49035)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  tcp: check skb is non-NULL in tcp_rto_delta_us()  We have some machines running stock Ubuntu 20.04.6 which is their 5.4.0-174-generic kernel that are running ceph and recently hit a null ptr dereference in tcp_rearm_rto(). Initially hitting it from the TLP path, but then later we also saw it getting hit from the RACK case as well. Here are examples of the oops messages we saw in each of those cases:  Jul 26 15:05:02 rx [11061395.780353] BUG: kernel NULL pointer dereference, address: 0000000000000020 Jul 26 15:05:02 rx [11061395.787572] #PF: supervisor read access in kernel mode Jul 26 15:05:02 rx [11061395.792971] #PF: error_code(0x0000) - not-present page Jul 26 15:05:02 rx [11061395.798362] PGD 0 P4D 0 Jul 26 15:05:02 rx [11061395.801164] Oops: 0000 [#1] SMP NOPTI Jul 26 15:05:02 rx [11061395.805091] CPU: 0 PID: 9180 Comm: msgr-worker-1 Tainted: G W 5.4.0-174-generic #193-Ubuntu Jul 26 15:05:02 rx [11061395.814996] Hardware name: Supermicro SMC 2x26 os-gen8 64C NVME-Y 256G/H12SSW-NTR, BIOS 2.5.V1.2U.NVMe.UEFI 05/09/2023 Jul 26 15:05:02 rx [11061395.825952] RIP: 0010:tcp_rearm_rto+0xe4/0x160 Jul 26 15:05:02 rx [11061395.830656] Code: 87 ca 04 00 00 00 5b 41 5c 41 5d 5d c3 c3 49 8b bc 24 40 06 00 00 eb 8d 48 bb cf f7 53 e3 a5 9b c4 20 4c 89 ef e8 0c fe 0e 00 &lt;48&gt; 8b 78 20 48 c1 ef 03 48 89 f8 41 8b bc 24 80 04 00 00 48 f7 e3 Jul 26 15:05:02 rx [11061395.849665] RSP: 0018:ffffb75d40003e08 EFLAGS: 00010246 Jul 26 15:05:02 rx [11061395.855149] RAX: 0000000000000000 RBX: 20c49ba5e353f7cf RCX: 0000000000000000 Jul 26 15:05:02 rx [11061395.862542] RDX: 0000000062177c30 RSI: 000000000000231c RDI: ffff9874ad283a60 Jul 26 15:05:02 rx [11061395.869933] RBP: ffffb75d40003e20 R08: 0000000000000000 R09: ffff987605e20aa8 Jul 26 15:05:02 rx [11061395.877318] R10: ffffb75d40003f00 R11: ffffb75d4460f740 R12: ffff9874ad283900 Jul 26 15:05:02 rx [11061395.884710] R13: ffff9874ad283a60 R14: ffff9874ad283980 R15: ffff9874ad283d30 Jul 26 15:05:02 rx [11061395.892095] FS: 00007f1ef4a2e700(0000) GS:ffff987605e00000(0000) knlGS:0000000000000000 Jul 26 15:05:02 rx [11061395.900438] CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 Jul 26 15:05:02 rx [11061395.906435] CR2: 0000000000000020 CR3: 0000003e450ba003 CR4: 0000000000760ef0 Jul 26 15:05:02 rx [11061395.913822] PKRU: 55555554 Jul 26 15:05:02 rx [11061395.916786] Call Trace: Jul 26 15:05:02 rx [11061395.919488] Jul 26 15:05:02 rx [11061395.921765] ? show_regs.cold+0x1a/0x1f Jul 26 15:05:02 rx [11061395.925859] ? __die+0x90/0xd9 Jul 26 15:05:02 rx [11061395.929169] ? no_context+0x196/0x380 Jul 26 15:05:02 rx [11061395.933088] ? ip6_protocol_deliver_rcu+0x4e0/0x4e0 Jul 26 15:05:02 rx [11061395.938216] ? ip6_sublist_rcv_finish+0x3d/0x50 Jul 26 15:05:02 rx [11061395.943000] ? __bad_area_nosemaphore+0x50/0x1a0 Jul 26 15:05:02 rx [11061395.947873] ? bad_area_nosemaphore+0x16/0x20 Jul 26 15:05:02 rx [11061395.952486] ? do_user_addr_fault+0x267/0x450 Jul 26 15:05:02 rx [11061395.957104] ? ipv6_list_rcv+0x112/0x140 Jul 26 15:05:02 rx [11061395.961279] ? __do_page_fault+0x58/0x90 Jul 26 15:05:02 rx [11061395.965458] ? do_page_fault+0x2c/0xe0 Jul 26 15:05:02 rx [11061395.969465] ? page_fault+0x34/0x40 Jul 26 15:05:02 rx [11061395.973217] ? tcp_rearm_rto+0xe4/0x160 Jul 26 15:05:02 rx [11061395.977313] ? tcp_rearm_rto+0xe4/0x160 Jul 26 15:05:02 rx [11061395.981408] tcp_send_loss_probe+0x10b/0x220 Jul 26 15:05:02 rx [11061395.985937] tcp_write_timer_handler+0x1b4/0x240 Jul 26 15:05:02 rx [11061395.990809] tcp_write_timer+0x9e/0xe0 Jul 26 15:05:02 rx [11061395.994814] ? tcp_write_timer_handler+0x240/0x240 Jul 26 15:05:02 rx [11061395.999866] call_timer_fn+0x32/0x130 Jul 26 15:05:02 rx [11061396.003782] __run_timers.part.0+0x180/0x280 Jul 26 15:05:02 rx [11061396.008309] ? recalibrate_cpu_khz+0x10/0x10 Jul 26 15:05:02 rx [11061396.012841] ? native_x2apic_icr_write+0x30/0x30 Jul 26 15:05:02 rx [11061396.017718] ? lapic_next_even ---truncated---(CVE-2024-47684)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  xfrm: validate new SA&apos;s prefixlen using SA family when sel.family is unset  This expands the validation introduced in commit 07bf7908950a (&quot;xfrm: Validate address prefix lengths in the xfrm selector.&quot;)  syzbot created an SA with     usersa.sel.family = AF_UNSPEC     usersa.sel.prefixlen_s = 128     usersa.family = AF_INET  Because of the AF_UNSPEC selector, verify_newsa_info doesn&apos;t put limits on prefixlen_{s,d}. But then copy_from_user_state sets x-&gt;sel.family to usersa.family (AF_INET). Do the same conversion in verify_newsa_info before validating prefixlen_{s,d}, since that&apos;s how prefixlen is going to be used later on.(CVE-2024-50142)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  vsock/virtio: Initialization of the dangling pointer occurring in vsk-&gt;trans  During loopback communication, a dangling pointer can be created in vsk-&gt;trans, potentially leading to a Use-After-Free condition.  This issue is resolved by initializing vsk-&gt;trans to NULL.(CVE-2024-50264)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  hv_sock: Initializing vsk-&gt;trans to NULL to prevent a dangling pointer  When hvs is released, there is a possibility that vsk-&gt;trans may not be initialized to NULL, which could lead to a dangling pointer. This issue is resolved by initializing vsk-&gt;trans to NULL.(CVE-2024-53103)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  net: fix data-races around sk-&gt;sk_forward_alloc  Syzkaller reported this warning:  ------------[ cut here ]------------  WARNING: CPU: 0 PID: 16 at net/ipv4/af_inet.c:156 inet_sock_destruct+0x1c5/0x1e0  Modules linked in:  CPU: 0 UID: 0 PID: 16 Comm: ksoftirqd/0 Not tainted 6.12.0-rc5 #26  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014  RIP: 0010:inet_sock_destruct+0x1c5/0x1e0  Code: 24 12 4c 89 e2 5b 48 c7 c7 98 ec bb 82 41 5c e9 d1 18 17 ff 4c 89 e6 5b 48 c7 c7 d0 ec bb 82 41 5c e9 bf 18 17 ff 0f 0b eb 83 &lt;0f&gt; 0b eb 97 0f 0b eb 87 0f 0b e9 68 ff ff ff 66 66 2e 0f 1f 84 00  RSP: 0018:ffffc9000008bd90 EFLAGS: 00010206  RAX: 0000000000000300 RBX: ffff88810b172a90 RCX: 0000000000000007  RDX: 0000000000000002 RSI: 0000000000000300 RDI: ffff88810b172a00  RBP: ffff88810b172a00 R08: ffff888104273c00 R09: 0000000000100007  R10: 0000000000020000 R11: 0000000000000006 R12: ffff88810b172a00  R13: 0000000000000004 R14: 0000000000000000 R15: ffff888237c31f78  FS:  0000000000000000(0000) GS:ffff888237c00000(0000) knlGS:0000000000000000  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  CR2: 00007ffc63fecac8 CR3: 000000000342e000 CR4: 00000000000006f0  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400  Call Trace:   &lt;TASK&gt;   ? __warn+0x88/0x130   ? inet_sock_destruct+0x1c5/0x1e0   ? report_bug+0x18e/0x1a0   ? handle_bug+0x53/0x90   ? exc_invalid_op+0x18/0x70   ? asm_exc_invalid_op+0x1a/0x20   ? inet_sock_destruct+0x1c5/0x1e0   __sk_destruct+0x2a/0x200   rcu_do_batch+0x1aa/0x530   ? rcu_do_batch+0x13b/0x530   rcu_core+0x159/0x2f0   handle_softirqs+0xd3/0x2b0   ? __pfx_smpboot_thread_fn+0x10/0x10   run_ksoftirqd+0x25/0x30   smpboot_thread_fn+0xdd/0x1d0   kthread+0xd3/0x100   ? __pfx_kthread+0x10/0x10   ret_from_fork+0x34/0x50   ? __pfx_kthread+0x10/0x10   ret_from_fork_asm+0x1a/0x30   &lt;/TASK&gt;  ---[ end trace 0000000000000000 ]---  Its possible that two threads call tcp_v6_do_rcv()/sk_forward_alloc_add() concurrently when sk-&gt;sk_state == TCP_LISTEN with sk-&gt;sk_lock unlocked, which triggers a data-race around sk-&gt;sk_forward_alloc: tcp_v6_rcv     tcp_v6_do_rcv         skb_clone_and_charge_r             sk_rmem_schedule                 __sk_mem_schedule                     sk_forward_alloc_add()             skb_set_owner_r                 sk_mem_charge                     sk_forward_alloc_add()         __kfree_skb             skb_release_all                 skb_release_head_state                     sock_rfree                         sk_mem_uncharge                             sk_forward_alloc_add()                             sk_mem_reclaim                                 // set local var reclaimable                                 __sk_mem_reclaim                                     sk_forward_alloc_add()  In this syzkaller testcase, two threads call tcp_v6_do_rcv() with skb-&gt;truesize=768, the sk_forward_alloc changes like this:  (cpu 1)             | (cpu 2)             | sk_forward_alloc  ...                 | ...                 | 0  __sk_mem_schedule() |                     | +4096 = 4096                      | __sk_mem_schedule() | +4096 = 8192  sk_mem_charge()     |                     | -768  = 7424                      | sk_mem_charge()     | -768  = 6656  ...                 |    ...              |  sk_mem_uncharge()   |                     | +768  = 7424  reclaimable=7424    |                     |                      | sk_mem_uncharge()   | +768  = 8192                      | reclaimable=8192    |  __sk_mem_reclaim()  |                     | -4096 = 4096                      | __sk_mem_reclaim()  | -8192 = -4096 != 0  The skb_clone_and_charge_r() should not be called in tcp_v6_do_rcv() when sk-&gt;sk_state is TCP_LISTEN, it happens later in tcp_v6_syn_recv_sock(). Fix the same issue in dccp_v6_do_rcv().(CVE-2024-53124)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  netlink: terminate outstanding dump on socket close  Netlink supports iterative dumping of data. It provides the families the following ops:  - start - (optional) kicks off the dumping process  - dump  - actual dump helper, keeps getting called until it returns 0  - done  - (optional) pairs with .start, can be used for cleanup The whole process is asynchronous and the repeated calls to .dump don&apos;t actually happen in a tight loop, but rather are triggered in response to recvmsg() on the socket.  This gives the user full control over the dump, but also means that the user can close the socket without getting to the end of the dump. To make sure .start is always paired with .done we check if there is an ongoing dump before freeing the socket, and if so call .done.  The complication is that sockets can get freed from BH and .done is allowed to sleep. So we use a workqueue to defer the call, when needed.  Unfortunately this does not work correctly. What we defer is not the cleanup but rather releasing a reference on the socket. We have no guarantee that we own the last reference, if someone else holds the socket they may release it in BH and we&apos;re back to square one.  The whole dance, however, appears to be unnecessary. Only the user can interact with dumps, so we can clean up when socket is closed. And close always happens in process context. Some async code may still access the socket after close, queue notification skbs to it etc. but no dumps can start, end or otherwise make progress.  Delete the workqueue and flush the dump state directly from the release handler. Note that further cleanup is possible in -next, for instance we now always call .done before releasing the main module reference, so dump doesn&apos;t have to take a reference of its own.(CVE-2024-53140)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  netfilter: ipset: add missing range check in bitmap_ip_uadt  When tb[IPSET_ATTR_IP_TO] is not present but tb[IPSET_ATTR_CIDR] exists, the values of ip and ip_to are slightly swapped. Therefore, the range check for ip should be done later, but this part is missing and it seems that the vulnerability occurs.  So we should add missing range checks and remove unnecessary range checks.(CVE-2024-53141)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  NFSD: Prevent a potential integer overflow  If the tag length is &gt;= U32_MAX - 3 then the &quot;length + 4&quot; addition can result in an integer overflow. Address this by splitting the decoding into several steps so that decode_cb_compound4res() does not have to perform arithmetic on the unsafe length value.(CVE-2024-53146)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  soc: qcom: geni-se: fix array underflow in geni_se_clk_tbl_get()  This loop is supposed to break if the frequency returned from clk_round_rate() is the same as on the previous iteration.  However, that check doesn&apos;t make sense on the first iteration through the loop. It leads to reading before the start of these-&gt;clk_perf_tbl[] array.(CVE-2024-53158)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  sh: intc: Fix use-after-free bug in register_intc_controller()  In the error handling for this function, d is freed without ever removing it from intc_list which would lead to a use after free. To fix this, let&apos;s only add it to the list after everything has succeeded.(CVE-2024-53165)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  NFSv4.0: Fix a use-after-free problem in the asynchronous open()  Yang Erkun reports that when two threads are opening files at the same time, and are forced to abort before a reply is seen, then the call to nfs_release_seqid() in nfs4_opendata_free() can result in a use-after-free of the pointer to the defunct rpc task of the other thread. The fix is to ensure that if the RPC call is aborted before the call to nfs_wait_on_sequence() is complete, then we must call nfs_release_seqid() in nfs4_open_release() before the rpc_task is freed.(CVE-2024-53173)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  um: net: Do not use drvdata in release  The drvdata is not available in release. Let&apos;s just use container_of() to get the uml_net instance. Otherwise, removing a network device will result in a crash:  RIP: 0033:net_device_release+0x10/0x6f RSP: 00000000e20c7c40  EFLAGS: 00010206 RAX: 000000006002e4e7 RBX: 00000000600f1baf RCX: 00000000624074e0 RDX: 0000000062778000 RSI: 0000000060551c80 RDI: 00000000627af028 RBP: 00000000e20c7c50 R08: 00000000603ad594 R09: 00000000e20c7b70 R10: 000000000000135a R11: 00000000603ad422 R12: 0000000000000000 R13: 0000000062c7af00 R14: 0000000062406d60 R15: 00000000627700b6 Kernel panic - not syncing: Segfault with no mm CPU: 0 UID: 0 PID: 29 Comm: kworker/0:2 Not tainted 6.12.0-rc6-g59b723cd2adb #1 Workqueue: events mc_work_proc Stack:  627af028 62c7af00 e20c7c80 60276fcd  62778000 603f5820 627af028 00000000  e20c7cb0 603a2bcd 627af000 62770010 Call Trace:  [&lt;60276fcd&gt;] device_release+0x70/0xba  [&lt;603a2bcd&gt;] kobject_put+0xba/0xe7  [&lt;60277265&gt;] put_device+0x19/0x1c  [&lt;60281266&gt;] platform_device_put+0x26/0x29  [&lt;60281e5f&gt;] platform_device_unregister+0x2c/0x2e  [&lt;6002ec9c&gt;] net_remove+0x63/0x69  [&lt;60031316&gt;] ? mconsole_reply+0x0/0x50  [&lt;600310c8&gt;] mconsole_remove+0x160/0x1cc  [&lt;60087d40&gt;] ? __remove_hrtimer+0x38/0x74  [&lt;60087ff8&gt;] ? hrtimer_try_to_cancel+0x8c/0x98  [&lt;6006b3cf&gt;] ? dl_server_stop+0x3f/0x48  [&lt;6006b390&gt;] ? dl_server_stop+0x0/0x48  [&lt;600672e8&gt;] ? dequeue_entities+0x327/0x390  [&lt;60038fa6&gt;] ? um_set_signals+0x0/0x43  [&lt;6003070c&gt;] mc_work_proc+0x77/0x91  [&lt;60057664&gt;] process_scheduled_works+0x1b3/0x2dd  [&lt;60055f32&gt;] ? assign_work+0x0/0x58  [&lt;60057f0a&gt;] worker_thread+0x1e9/0x293  [&lt;6005406f&gt;] ? set_pf_worker+0x0/0x64  [&lt;6005d65d&gt;] ? arch_local_irq_save+0x0/0x2d  [&lt;6005d748&gt;] ? kthread_exit+0x0/0x3a  [&lt;60057d21&gt;] ? worker_thread+0x0/0x293  [&lt;6005dbf1&gt;] kthread+0x126/0x12b  [&lt;600219c5&gt;] new_thread_handler+0x85/0xb6(CVE-2024-53183)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  um: ubd: Do not use drvdata in release  The drvdata is not available in release. Let&apos;s just use container_of() to get the ubd instance. Otherwise, removing a ubd device will result in a crash:  RIP: 0033:blk_mq_free_tag_set+0x1f/0xba RSP: 00000000e2083bf0  EFLAGS: 00010246 RAX: 000000006021463a RBX: 0000000000000348 RCX: 0000000062604d00 RDX: 0000000004208060 RSI: 00000000605241a0 RDI: 0000000000000348 RBP: 00000000e2083c10 R08: 0000000062414010 R09: 00000000601603f7 R10: 000000000000133a R11: 000000006038c4bd R12: 0000000000000000 R13: 0000000060213a5c R14: 0000000062405d20 R15: 00000000604f7aa0 Kernel panic - not syncing: Segfault with no mm CPU: 0 PID: 17 Comm: kworker/0:1 Not tainted 6.8.0-rc3-00107-gba3f67c11638 #1 Workqueue: events mc_work_proc Stack:  00000000 604f7ef0 62c5d000 62405d20  e2083c30 6002c776 6002c755 600e47ff  e2083c60 6025ffe3 04208060 603d36e0 Call Trace:  [&lt;6002c776&gt;] ubd_device_release+0x21/0x55  [&lt;6002c755&gt;] ? ubd_device_release+0x0/0x55  [&lt;600e47ff&gt;] ? kfree+0x0/0x100  [&lt;6025ffe3&gt;] device_release+0x70/0xba  [&lt;60381d6a&gt;] kobject_put+0xb5/0xe2  [&lt;6026027b&gt;] put_device+0x19/0x1c  [&lt;6026a036&gt;] platform_device_put+0x26/0x29  [&lt;6026ac5a&gt;] platform_device_unregister+0x2c/0x2e  [&lt;6002c52e&gt;] ubd_remove+0xb8/0xd6  [&lt;6002bb74&gt;] ? mconsole_reply+0x0/0x50  [&lt;6002b926&gt;] mconsole_remove+0x160/0x1cc  [&lt;6002bbbc&gt;] ? mconsole_reply+0x48/0x50  [&lt;6003379c&gt;] ? um_set_signals+0x3b/0x43  [&lt;60061c55&gt;] ? update_min_vruntime+0x14/0x70  [&lt;6006251f&gt;] ? dequeue_task_fair+0x164/0x235  [&lt;600620aa&gt;] ? update_cfs_group+0x0/0x40  [&lt;603a0e77&gt;] ? __schedule+0x0/0x3ed  [&lt;60033761&gt;] ? um_set_signals+0x0/0x43  [&lt;6002af6a&gt;] mc_work_proc+0x77/0x91  [&lt;600520b4&gt;] process_scheduled_works+0x1af/0x2c3  [&lt;6004ede3&gt;] ? assign_work+0x0/0x58  [&lt;600527a1&gt;] worker_thread+0x2f7/0x37a  [&lt;6004ee3b&gt;] ? set_pf_worker+0x0/0x64  [&lt;6005765d&gt;] ? arch_local_irq_save+0x0/0x2d  [&lt;60058e07&gt;] ? kthread_exit+0x0/0x3a  [&lt;600524aa&gt;] ? worker_thread+0x0/0x37a  [&lt;60058f9f&gt;] kthread+0x130/0x135  [&lt;6002068e&gt;] new_thread_handler+0x85/0xb6(CVE-2024-53184)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  PCI: Fix use-after-free of slot-&gt;bus on hot remove  Dennis reports a boot crash on recent Lenovo laptops with a USB4 dock.  Since commit 0fc70886569c (&quot;thunderbolt: Reset USB4 v2 host router&quot;) and commit 59a54c5f3dbd (&quot;thunderbolt: Reset topology created by the boot firmware&quot;), USB4 v2 and v1 Host Routers are reset on probe of the thunderbolt driver.  The reset clears the Presence Detect State and Data Link Layer Link Active bits at the USB4 Host Router&apos;s Root Port and thus causes hot removal of the dock.  The crash occurs when pciehp is unbound from one of the dock&apos;s Downstream Ports:  pciehp creates a pci_slot on bind and destroys it on unbind.  The pci_slot contains a pointer to the pci_bus below the Downstream Port, but a reference on that pci_bus is never acquired.  The pci_bus is destroyed before the pci_slot, so a use-after-free ensues when pci_slot_release() accesses slot-&gt;bus.  In principle this should not happen because pci_stop_bus_device() unbinds pciehp (and therefore destroys the pci_slot) before the pci_bus is destroyed by pci_remove_bus_device().  However the stacktrace provided by Dennis shows that pciehp is unbound from pci_remove_bus_device() instead of pci_stop_bus_device().  To understand the significance of this, one needs to know that the PCI core uses a two step process to remove a portion of the hierarchy:  It first unbinds all drivers in the sub-hierarchy in pci_stop_bus_device() and then actually removes the devices in pci_remove_bus_device().  There is no precaution to prevent driver binding in-between pci_stop_bus_device() and pci_remove_bus_device().  In Dennis&apos; case, it seems removal of the hierarchy by pciehp races with driver binding by pci_bus_add_devices().  pciehp is bound to the Downstream Port after pci_stop_bus_device() has run, so it is unbound by pci_remove_bus_device() instead of pci_stop_bus_device().  Because the pci_bus has already been destroyed at that point, accesses to it result in a use-after-free.  One might conclude that driver binding needs to be prevented after pci_stop_bus_device() has run.  However it seems risky that pci_slot points to pci_bus without holding a reference.  Solely relying on correct ordering of driver unbind versus pci_bus destruction is certainly not defensive programming.  If pci_slot has a need to access data in pci_bus, it ought to acquire a reference.  Amend pci_create_slot() accordingly.  Dennis reports that the crash is not reproducible with this change.  Abridged stacktrace:    pcieport 0000:00:07.0: PME: Signaling with IRQ 156   pcieport 0000:00:07.0: pciehp: Slot #12 AttnBtn- PwrCtrl- MRL- AttnInd- PwrInd- HotPlug+ Surprise+ Interlock- NoCompl+ IbPresDis- LLActRep+   pci_bus 0000:20: dev 00, created physical slot 12   pcieport 0000:00:07.0: pciehp: Slot(12): Card not present   ...   pcieport 0000:21:02.0: pciehp: pcie_disable_notification: SLOTCTRL d8 write cmd 0   Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6b6b: 0000 [#1] PREEMPT SMP NOPTI   CPU: 13 UID: 0 PID: 134 Comm: irq/156-pciehp Not tainted 6.11.0-devel+ #1   RIP: 0010:dev_driver_string+0x12/0x40   pci_destroy_slot   pciehp_remove   pcie_port_remove_service   device_release_driver_internal   bus_remove_device   device_del   device_unregister   remove_iter   device_for_each_child   pcie_portdrv_remove   pci_device_remove   device_release_driver_internal   bus_remove_device   device_del   pci_remove_bus_device (recursive invocation)   pci_remove_bus_device   pciehp_unconfigure_device   pciehp_disable_slot   pciehp_handle_presence_or_link_change   pciehp_ist(CVE-2024-53194)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ALSA: usb-audio: Fix potential out-of-bound accesses for Extigy and Mbox devices  A bogus device can provide a bNumConfigurations value that exceeds the initial value used in usb_get_configuration for allocating dev-&gt;config.  This can lead to out-of-bounds accesses later, e.g. in usb_destroy_configuration.(CVE-2024-53197)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  vfio/pci: Properly hide first-in-list PCIe extended capability  There are cases where a PCIe extended capability should be hidden from the user. For example, an unknown capability (i.e., capability with ID greater than PCI_EXT_CAP_ID_MAX) or a capability that is intentionally chosen to be hidden from the user.  Hiding a capability is done by virtualizing and modifying the &apos;Next Capability Offset&apos; field of the previous capability so it points to the capability after the one that should be hidden.  The special case where the first capability in the list should be hidden is handled differently because there is no previous capability that can be modified. In this case, the capability ID and version are zeroed while leaving the next pointer intact. This hides the capability and leaves an anchor for the rest of the capability list.  However, today, hiding the first capability in the list is not done properly if the capability is unknown, as struct vfio_pci_core_device-&gt;pci_config_map is set to the capability ID during initialization but the capability ID is not properly checked later when used in vfio_config_do_rw(). This leads to the following warning [1] and to an out-of-bounds access to ecap_perms array.  Fix it by checking cap_id in vfio_config_do_rw(), and if it is greater than PCI_EXT_CAP_ID_MAX, use an alternative struct perm_bits for direct read only access instead of the ecap_perms array.  Note that this is safe since the above is the only case where cap_id can exceed PCI_EXT_CAP_ID_MAX (except for the special capabilities, which are already checked before).  [1]  WARNING: CPU: 118 PID: 5329 at drivers/vfio/pci/vfio_pci_config.c:1900 vfio_pci_config_rw+0x395/0x430 [vfio_pci_core] CPU: 118 UID: 0 PID: 5329 Comm: simx-qemu-syste Not tainted 6.12.0+ #1 (snip) Call Trace:  &lt;TASK&gt;  ? show_regs+0x69/0x80  ? __warn+0x8d/0x140  ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]  ? report_bug+0x18f/0x1a0  ? handle_bug+0x63/0xa0  ? exc_invalid_op+0x19/0x70  ? asm_exc_invalid_op+0x1b/0x20  ? vfio_pci_config_rw+0x395/0x430 [vfio_pci_core]  ? vfio_pci_config_rw+0x244/0x430 [vfio_pci_core]  vfio_pci_rw+0x101/0x1b0 [vfio_pci_core]  vfio_pci_core_read+0x1d/0x30 [vfio_pci_core]  vfio_device_fops_read+0x27/0x40 [vfio]  vfs_read+0xbd/0x340  ? vfio_device_fops_unl_ioctl+0xbb/0x740 [vfio]  ? __rseq_handle_notify_resume+0xa4/0x4b0  __x64_sys_pread64+0x96/0xc0  x64_sys_call+0x1c3d/0x20d0  do_syscall_64+0x4d/0x120  entry_SYSCALL_64_after_hwframe+0x76/0x7e(CVE-2024-53214)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  NFSD: Prevent NULL dereference in nfsd4_process_cb_update()  @ses is initialized to NULL. If __nfsd4_find_backchannel() finds no available backchannel session, setup_callback_client() will try to dereference @ses and segfault.(CVE-2024-53217)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ALSA: 6fire: Release resources at card release  The current 6fire code tries to release the resources right after the call of usb6fire_chip_abort().  But at this moment, the card object might be still in use (as we&apos;re calling snd_card_free_when_closed()).  For avoid potential UAFs, move the release of resources to the card&apos;s private_free instead of the manual call of usb6fire_chip_destroy() at the USB disconnect callback.(CVE-2024-53239)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ALSA: caiaq: Use snd_card_free_when_closed() at disconnection  The USB disconnect callback is supposed to be short and not too-long waiting.  OTOH, the current code uses snd_card_free() at disconnection, but this waits for the close of all used fds, hence it can take long.  It eventually blocks the upper layer USB ioctls, which may trigger a soft lockup.  An easy workaround is to replace snd_card_free() with snd_card_free_when_closed().  This variant returns immediately while the release of resources is done asynchronously by the card device release at the last close.  This patch also splits the code to the disconnect and the free phases; the former is called immediately at the USB disconnect callback while the latter is called from the card destructor.(CVE-2024-56531)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ALSA: us122l: Use snd_card_free_when_closed() at disconnection  The USB disconnect callback is supposed to be short and not too-long waiting.  OTOH, the current code uses snd_card_free() at disconnection, but this waits for the close of all used fds, hence it can take long.  It eventually blocks the upper layer USB ioctls, which may trigger a soft lockup.  An easy workaround is to replace snd_card_free() with snd_card_free_when_closed().  This variant returns immediately while the release of resources is done asynchronously by the card device release at the last close.  The loop of us122l-&gt;mmap_count check is dropped as well.  The check is useless for the asynchronous operation with *_when_closed().(CVE-2024-56532)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  wifi: mwifiex: Fix memcpy() field-spanning write warning in mwifiex_config_scan()  Replace one-element array with a flexible-array member in `struct mwifiex_ie_types_wildcard_ssid_params` to fix the following warning on a MT8173 Chromebook (mt8173-elm-hana):  [  356.775250] ------------[ cut here ]------------ [  356.784543] memcpy: detected field-spanning write (size 6) of single field &quot;wildcard_ssid_tlv-&gt;ssid&quot; at drivers/net/wireless/marvell/mwifiex/scan.c:904 (size 1) [  356.813403] WARNING: CPU: 3 PID: 742 at drivers/net/wireless/marvell/mwifiex/scan.c:904 mwifiex_scan_networks+0x4fc/0xf28 [mwifiex]  The &quot;(size 6)&quot; above is exactly the length of the SSID of the network this device was connected to. The source of the warning looks like:      ssid_len = user_scan_in-&gt;ssid_list[i].ssid_len;     [...]     memcpy(wildcard_ssid_tlv-&gt;ssid,            user_scan_in-&gt;ssid_list[i].ssid, ssid_len);  There is a #define WILDCARD_SSID_TLV_MAX_SIZE that uses sizeof() on this struct, but it already didn&apos;t account for the size of the one-element array, so it doesn&apos;t need to be changed.(CVE-2024-56539)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  crypto: bcm - add error check in the ahash_hmac_init function  The ahash_init functions may return fails. The ahash_hmac_init should not return ok when ahash_init returns error. For an example, ahash_init will return -ENOMEM when allocation memory is error.(CVE-2024-56681)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  media: wl128x: Fix atomicity violation in fmc_send_cmd()  Atomicity violation occurs when the fmc_send_cmd() function is executed simultaneously with the modification of the fmdev-&gt;resp_skb value. Consider a scenario where, after passing the validity check within the function, a non-null fmdev-&gt;resp_skb variable is assigned a null value. This results in an invalid fmdev-&gt;resp_skb variable passing the validity check. As seen in the later part of the function, skb = fmdev-&gt;resp_skb; when the invalid fmdev-&gt;resp_skb passes the check, a null pointer dereference error may occur at line 478, evt_hdr = (void *)skb-&gt;data;  To address this issue, it is recommended to include the validity check of fmdev-&gt;resp_skb within the locked section of the function. This modification ensures that the value of fmdev-&gt;resp_skb does not change during the validation process, thereby maintaining its validity.  This possible bug is found by an experimental static analysis tool developed by our team. This tool analyzes the locking APIs to extract function pairs that can be concurrently executed, and then analyzes the instructions in the paired functions to identify possible concurrency bugs including data races and atomicity violations.(CVE-2024-56700)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  9p/xen: fix release of IRQ  Kernel logs indicate an IRQ was double-freed.  Pass correct device ID during IRQ release.  [Dominique: remove confusing variable reset to 0](CVE-2024-56704)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  fbdev: sh7760fb: Fix a possible memory leak in sh7760fb_alloc_mem()  When information such as info-&gt;screen_base is not ready, calling sh7760fb_free_mem() does not release memory correctly. Call dma_free_coherent() instead.(CVE-2024-56746)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  scsi: qedi: Fix a possible memory leak in qedi_alloc_and_init_sb()  Hook &quot;qedi_ops-&gt;common-&gt;sb_init = qed_sb_init&quot; does not release the DMA memory sb_virt when it fails. Add dma_free_coherent() to free it. This is the same way as qedr_alloc_mem_sb() and qede_alloc_mem_sb().(CVE-2024-56747)",
  "id": "OESA-2025-1034",
  "modified": "2025-09-03T06:18:44.941950Z",
  "published": "2025-01-10T13:01:49Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-1034"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49034"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2022-49035"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47684"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50142"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50264"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53103"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53124"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53140"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53141"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53146"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53158"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53165"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53173"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53183"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53184"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53194"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53197"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53214"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53217"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53239"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56531"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56532"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56539"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56681"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56700"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56704"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56746"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-56747"
    }
  ],
  "schema_version": "1.7.3",
  "summary": "kernel security update",
  "upstream": [
    "CVE-2022-49034",
    "CVE-2022-49035",
    "CVE-2024-47684",
    "CVE-2024-50142",
    "CVE-2024-50264",
    "CVE-2024-53103",
    "CVE-2024-53124",
    "CVE-2024-53140",
    "CVE-2024-53141",
    "CVE-2024-53146",
    "CVE-2024-53158",
    "CVE-2024-53165",
    "CVE-2024-53173",
    "CVE-2024-53183",
    "CVE-2024-53184",
    "CVE-2024-53194",
    "CVE-2024-53197",
    "CVE-2024-53214",
    "CVE-2024-53217",
    "CVE-2024-53239",
    "CVE-2024-56531",
    "CVE-2024-56532",
    "CVE-2024-56539",
    "CVE-2024-56681",
    "CVE-2024-56700",
    "CVE-2024-56704",
    "CVE-2024-56746",
    "CVE-2024-56747"
  ]
}