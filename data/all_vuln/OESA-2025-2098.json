{
  "affected": [
    {
      "database_specific": {
        "source": "https://repo.openeuler.org/security/data/osv/OESA-2025-2098.json"
      },
      "ecosystem_specific": {
        "aarch64": [
          "uv-0.8.8-1.oe2403sp2.aarch64.rpm"
        ],
        "src": [
          "uv-0.8.8-1.oe2403sp2.src.rpm"
        ],
        "x86_64": [
          "uv-0.8.8-1.oe2403sp2.x86_64.rpm"
        ]
      },
      "package": {
        "ecosystem": "openEuler:24.03-LTS-SP2",
        "name": "uv",
        "purl": "pkg:rpm/openEuler/uv&distro=openEuler-24.03-LTS-SP2"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "0.8.8-1.oe2403sp2"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "database_specific": {
    "severity": "High"
  },
  "details": "An extremely fast Python package and project manager, written in Rust.\r\n\r\nSecurity Fix(es):\n\nuv is a Python package and project manager written in Rust. In versions 0.8.5 and earlier, remote ZIP archives were handled in a streamwise fashion, and file entries were not reconciled against the archive&apos;s central directory. An attacker could contrive a ZIP archive that would extract with legitimate contents on some package installers, and malicious contents on others due to multiple local file entries. An attacker could  also contrive a &quot;stacked&quot; ZIP input with multiple internal ZIPs, which would be handled differently by different package installers. The attacker could choose which installer to target in both scenarios. This issue is fixed in version 0.8.6. To work around this issue, users may choose to set UV_INSECURE_NO_ZIP_VALIDATION=1 to revert to the previous behavior.(CVE-2025-54368)\n\nslab is a pre-allocated storage for a uniform data type. In version 0.4.10, the get_disjoint_mut method incorrectly checked if indices were within the slab&apos;s capacity instead of its length, allowing access to uninitialized memory. This could lead to undefined behavior or potential crashes. This has been fixed in slab 0.4.11. A workaround for this issue involves to avoid using get_disjoint_mut with indices that might be beyond the slab&apos;s actual length.(CVE-2025-55159)",
  "id": "OESA-2025-2098",
  "modified": "2025-09-05T13:18:05.944832Z",
  "published": "2025-09-05T12:39:37Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2025-2098"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-54368"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2025-55159"
    }
  ],
  "schema_version": "1.7.3",
  "summary": "uv security update",
  "upstream": [
    "CVE-2025-54368",
    "CVE-2025-55159"
  ]
}