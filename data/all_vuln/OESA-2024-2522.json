{
  "affected": [
    {
      "database_specific": {
        "source": "https://repo.openeuler.org/security/data/osv/OESA-2024-2522.json"
      },
      "ecosystem_specific": {
        "aarch64": [
          "bpftool-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "bpftool-debuginfo-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-debuginfo-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-debugsource-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-devel-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-headers-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-source-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-tools-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-tools-debuginfo-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "kernel-tools-devel-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "perf-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "perf-debuginfo-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "python3-perf-6.6.0-61.0.0.60.oe2403.aarch64.rpm",
          "python3-perf-debuginfo-6.6.0-61.0.0.60.oe2403.aarch64.rpm"
        ],
        "src": [
          "kernel-6.6.0-61.0.0.60.oe2403.src.rpm"
        ],
        "x86_64": [
          "bpftool-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "bpftool-debuginfo-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-debuginfo-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-debugsource-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-devel-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-headers-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-source-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-tools-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-tools-debuginfo-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "kernel-tools-devel-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "perf-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "perf-debuginfo-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "python3-perf-6.6.0-61.0.0.60.oe2403.x86_64.rpm",
          "python3-perf-debuginfo-6.6.0-61.0.0.60.oe2403.x86_64.rpm"
        ]
      },
      "package": {
        "ecosystem": "openEuler:24.03-LTS",
        "name": "kernel",
        "purl": "pkg:rpm/openEuler/kernel&distro=openEuler-24.03-LTS"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.6.0-61.0.0.60.oe2403"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "database_specific": {
    "severity": "High"
  },
  "details": "The Linux Kernel, the operating system core itself.\r\n\r\nSecurity Fix(es):\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nKVM: SVM: WARN on vNMI + NMI window iff NMIs are outright masked\r\n\r\nWhen requesting an NMI window, WARN on vNMI support being enabled if and\nonly if NMIs are actually masked, i.e. if the vCPU is already handling an\nNMI.  KVM&apos;s ABI for NMIs that arrive simultanesouly (from KVM&apos;s point of\nview) is to inject one NMI and pend the other.  When using vNMI, KVM pends\nthe second NMI simply by setting V_NMI_PENDING, and lets the CPU do the\nrest (hardware automatically sets V_NMI_BLOCKING when an NMI is injected).\r\n\r\nHowever, if KVM can&apos;t immediately inject an NMI, e.g. because the vCPU is\nin an STI shadow or is running with GIF=0, then KVM will request an NMI\nwindow and trigger the WARN (but still function correctly).\r\n\r\nWhether or not the GIF=0 case makes sense is debatable, as the intent of\nKVM&apos;s behavior is to provide functionality that is as close to real\nhardware as possible.  E.g. if two NMIs are sent in quick succession, the\nprobability of both NMIs arriving in an STI shadow is infinitesimally low\non real hardware, but significantly larger in a virtual environment, e.g.\nif the vCPU is preempted in the STI shadow.  For GIF=0, the argument isn&apos;t\nas clear cut, because the window where two NMIs can collide is much larger\nin bare metal (though still small).\r\n\r\nThat said, KVM should not have divergent behavior for the GIF=0 case based\non whether or not vNMI support is enabled.  And KVM has allowed\nsimultaneous NMIs with GIF=0 for over a decade, since commit 7460fb4a3400\n(&quot;KVM: Fix simultaneous NMIs&quot;).  I.e. KVM&apos;s GIF=0 handling shouldn&apos;t be\nmodified without a *really* good reason to do so, and if KVM&apos;s behavior\nwere to be modified, it should be done irrespective of vNMI support.(CVE-2024-39483)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nserial: sc16is7xx: fix invalid FIFO access with special register set\r\n\r\nWhen enabling access to the special register set, Receiver time-out and\nRHR interrupts can happen. In this case, the IRQ handler will try to read\nfrom the FIFO thru the RHR register at address 0x00, but address 0x00 is\nmapped to DLL register, resulting in erroneous FIFO reading.\r\n\r\nCall graph example:\n    sc16is7xx_startup(): entry\n    sc16is7xx_ms_proc(): entry\n    sc16is7xx_set_termios(): entry\n    sc16is7xx_set_baud(): DLH/DLL = $009C --&gt; access special register set\n    sc16is7xx_port_irq() entry            --&gt; IIR is 0x0C\n    sc16is7xx_handle_rx() entry\n    sc16is7xx_fifo_read(): --&gt; unable to access FIFO (RHR) because it is\n                               mapped to DLL (LCR=LCR_CONF_MODE_A)\n    sc16is7xx_set_baud(): exit --&gt; Restore access to general register set\r\n\r\nFix the problem by claiming the efr_lock mutex when accessing the Special\nregister set.(CVE-2024-44950)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ns390/dasd: fix error recovery leading to data corruption on ESE devices\r\n\r\nExtent Space Efficient (ESE) or thin provisioned volumes need to be\nformatted on demand during usual IO processing.\r\n\r\nThe dasd_ese_needs_format function checks for error codes that signal\nthe non existence of a proper track format.\r\n\r\nThe check for incorrect length is to imprecise since other error cases\nleading to transport of insufficient data also have this flag set.\nThis might lead to data corruption in certain error cases for example\nduring a storage server warmstart.\r\n\r\nFix by removing the check for incorrect length and replacing by\nexplicitly checking for invalid track format in transport mode.\r\n\r\nAlso remove the check for file protected since this is not a valid\nESE handling case.(CVE-2024-45026)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/amd/display: Add missing NULL pointer check within dpcd_extend_address_range\r\n\r\n[Why &amp; How]\nASSERT if return NULL from kcalloc.(CVE-2024-46808)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/amd/display: Check link_index before accessing dc-&gt;links[]\r\n\r\n[WHY &amp; HOW]\ndc-&gt;links[] has max size of MAX_LINKS and NULL is return when trying to\naccess with out-of-bound index.\r\n\r\nThis fixes 3 OVERRUN and 1 RESOURCE_LEAK issues reported by Coverity.(CVE-2024-46813)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nwifi: iwlwifi: mvm: use IWL_FW_CHECK for link ID check\r\n\r\nThe lookup function iwl_mvm_rcu_fw_link_id_to_link_conf() is\nnormally called with input from the firmware, so it should use\nIWL_FW_CHECK() instead of WARN_ON().(CVE-2024-46825)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  scsi: sd: Fix off-by-one error in sd_read_block_characteristics()  Ff the device returns page 0xb1 with length 8 (happens with qemu v2.x, for example), sd_read_block_characteristics() may attempt an out-of-bounds memory access when accessing the zoned field at offset 8.(CVE-2024-47682)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  block, bfq: fix possible UAF for bfqq-&gt;bic with merge chain  1) initial state, three tasks:    Process 1       Process 2 Process 3    (BIC1)          (BIC2)   (BIC3)     |  \u039b            |  \u039b    |  \u039b     |  |            |  |    |  |     V  |            V  |    V  |     bfqq1           bfqq2    bfqq3 process ref:    1      1      1  2) bfqq1 merged to bfqq2:    Process 1       Process 2 Process 3    (BIC1)          (BIC2)   (BIC3)     |               |    |  \u039b     \\--------------\\|    |  |                     V    V  |     bfqq1---------&gt;bfqq2    bfqq3 process ref:    0      2      1  3) bfqq2 merged to bfqq3:    Process 1       Process 2 Process 3    (BIC1)          (BIC2)   (BIC3)   here -&gt; \u039b                |    |     \\--------------\\ \\-------------\\|                     V    V     bfqq1---------&gt;bfqq2----------&gt;bfqq3 process ref:    0      1      3  In this case, IO from Process 1 will get bfqq2 from BIC1 first, and then get bfqq3 through merge chain, and finially handle IO by bfqq3. Howerver, current code will think bfqq2 is owned by BIC1, like initial state, and set bfqq2-&gt;bic to BIC1.  bfq_insert_request -&gt; by Process 1  bfqq = bfq_init_rq(rq)   bfqq = bfq_get_bfqq_handle_split    bfqq = bic_to_bfqq    -&gt; get bfqq2 from BIC1  bfqq-&gt;ref++  rq-&gt;elv.priv[0] = bic  rq-&gt;elv.priv[1] = bfqq  if (bfqq_process_refs(bfqq) == 1)   bfqq-&gt;bic = bic   -&gt; record BIC1 to bfqq2    __bfq_insert_request    new_bfqq = bfq_setup_cooperator    -&gt; get bfqq3 from bfqq2-&gt;new_bfqq    bfqq_request_freed(bfqq)    new_bfqq-&gt;ref++    rq-&gt;elv.priv[1] = new_bfqq    -&gt; handle IO by bfqq3  Fix the problem by checking bfqq is from merge chain fist. And this might fix a following problem reported by our syzkaller(unreproducible):  ================================================================== BUG: KASAN: slab-use-after-free in bfq_do_early_stable_merge block/bfq-iosched.c:5692 [inline] BUG: KASAN: slab-use-after-free in bfq_do_or_sched_stable_merge block/bfq-iosched.c:5805 [inline] BUG: KASAN: slab-use-after-free in bfq_get_queue+0x25b0/0x2610 block/bfq-iosched.c:5889 Write of size 1 at addr ffff888123839eb8 by task kworker/0:1H/18595  CPU: 0 PID: 18595 Comm: kworker/0:1H Tainted: G             L     6.6.0-07439-gba2303cacfda #6 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org 04/01/2014 Workqueue: kblockd blk_mq_requeue_work Call Trace:  &lt;TASK&gt;  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x91/0xf0 lib/dump_stack.c:106  print_address_description mm/kasan/report.c:364 [inline]  print_report+0x10d/0x610 mm/kasan/report.c:475  kasan_report+0x8e/0xc0 mm/kasan/report.c:588  bfq_do_early_stable_merge block/bfq-iosched.c:5692 [inline]  bfq_do_or_sched_stable_merge block/bfq-iosched.c:5805 [inline]  bfq_get_queue+0x25b0/0x2610 block/bfq-iosched.c:5889  bfq_get_bfqq_handle_split+0x169/0x5d0 block/bfq-iosched.c:6757  bfq_init_rq block/bfq-iosched.c:6876 [inline]  bfq_insert_request block/bfq-iosched.c:6254 [inline]  bfq_insert_requests+0x1112/0x5cf0 block/bfq-iosched.c:6304  blk_mq_insert_request+0x290/0x8d0 block/blk-mq.c:2593  blk_mq_requeue_work+0x6bc/0xa70 block/blk-mq.c:1502  process_one_work kernel/workqueue.c:2627 [inline]  process_scheduled_works+0x432/0x13f0 kernel/workqueue.c:2700  worker_thread+0x6f2/0x1160 kernel/workqueue.c:2781  kthread+0x33c/0x440 kernel/kthread.c:388  ret_from_fork+0x4d/0x80 arch/x86/kernel/process.c:147  ret_from_fork_asm+0x1b/0x30 arch/x86/entry/entry_64.S:305  &lt;/TASK&gt;  Allocated by task 20776:  kasan_save_stack+0x20/0x40 mm/kasan/common.c:45  kasan_set_track+0x25/0x30 mm/kasan/common.c:52  __kasan_slab_alloc+0x87/0x90 mm/kasan/common.c:328  kasan_slab_alloc include/linux/kasan.h:188 [inline]  slab_post_alloc_hook mm/slab.h:763 [inline]  slab_alloc_node mm/slub.c:3458 [inline]  kmem_cache_alloc_node+0x1a4/0x6f0 mm/slub.c:3503  ioc_create_icq block/blk-ioc.c:370 [inline] ---truncated---(CVE-2024-47706)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  wifi: mt76: mt7996: use hweight16 to get correct tx antenna  The chainmask is u16 so using hweight8 cannot get correct tx_ant. Without this patch, the tx_ant of band 2 would be -1 and lead to the following issue: BUG: KASAN: stack-out-of-bounds in mt7996_mcu_add_sta+0x12e0/0x16e0 [mt7996e](CVE-2024-47714)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  wifi: mt76: mt7915: fix oops on non-dbdc mt7986  mt7915_band_config() sets band_idx = 1 on the main phy for mt7986 with MT7975_ONE_ADIE or MT7976_ONE_ADIE.  Commit 0335c034e726 (&quot;wifi: mt76: fix race condition related to checking tx queue fill status&quot;) introduced a dereference of the phys array indirectly indexed by band_idx via wcid-&gt;phy_idx in mt76_wcid_cleanup(). This caused the following Oops on affected mt7986 devices:   Unable to handle kernel read from unreadable memory at virtual address 0000000000000024  Mem abort info:    ESR = 0x0000000096000005    EC = 0x25: DABT (current EL), IL = 32 bits    SET = 0, FnV = 0    EA = 0, S1PTW = 0    FSC = 0x05: level 1 translation fault  Data abort info:    ISV = 0, ISS = 0x00000005    CM = 0, WnR = 0  user pgtable: 4k pages, 39-bit VAs, pgdp=0000000042545000  [0000000000000024] pgd=0000000000000000, p4d=0000000000000000, pud=0000000000000000  Internal error: Oops: 0000000096000005 [#1] SMP  Modules linked in: ... mt7915e mt76_connac_lib mt76 mac80211 cfg80211 ...  CPU: 2 PID: 1631 Comm: hostapd Not tainted 5.15.150 #0  Hardware name: ZyXEL EX5700 (Telenor) (DT)  pstate: 80400005 (Nzcv daif +PAN -UAO -TCO -DIT -SSBS BTYPE=--)  pc : mt76_wcid_cleanup+0x84/0x22c [mt76]  lr : mt76_wcid_cleanup+0x64/0x22c [mt76]  sp : ffffffc00a803700  x29: ffffffc00a803700 x28: ffffff80008f7300 x27: ffffff80003f3c00  x26: ffffff80000a7880 x25: ffffffc008c26e00 x24: 0000000000000001  x23: ffffffc000a68114 x22: 0000000000000000 x21: ffffff8004172cc8  x20: ffffffc00a803748 x19: ffffff8004152020 x18: 0000000000000000  x17: 00000000000017c0 x16: ffffffc008ef5000 x15: 0000000000000be0  x14: ffffff8004172e28 x13: ffffff8004172e28 x12: 0000000000000000  x11: 0000000000000000 x10: ffffff8004172e30 x9 : ffffff8004172e28  x8 : 0000000000000000 x7 : ffffff8004156020 x6 : 0000000000000000  x5 : 0000000000000031 x4 : 0000000000000000 x3 : 0000000000000001  x2 : 0000000000000000 x1 : ffffff80008f7300 x0 : 0000000000000024  Call trace:   mt76_wcid_cleanup+0x84/0x22c [mt76]   __mt76_sta_remove+0x70/0xbc [mt76]   mt76_sta_state+0x8c/0x1a4 [mt76]   mt7915_eeprom_get_power_delta+0x11e4/0x23a0 [mt7915e]   drv_sta_state+0x144/0x274 [mac80211]   sta_info_move_state+0x1cc/0x2a4 [mac80211]   sta_set_sinfo+0xaf8/0xc24 [mac80211]   sta_info_destroy_addr_bss+0x4c/0x6c [mac80211]    ieee80211_color_change_finish+0x1c08/0x1e70 [mac80211]   cfg80211_check_station_change+0x1360/0x4710 [cfg80211]   genl_family_rcv_msg_doit+0xb4/0x110   genl_rcv_msg+0xd0/0x1bc   netlink_rcv_skb+0x58/0x120   genl_rcv+0x34/0x50   netlink_unicast+0x1f0/0x2ec   netlink_sendmsg+0x198/0x3d0   ____sys_sendmsg+0x1b0/0x210   ___sys_sendmsg+0x80/0xf0   __sys_sendmsg+0x44/0xa0   __arm64_sys_sendmsg+0x20/0x30   invoke_syscall.constprop.0+0x4c/0xe0   do_el0_svc+0x40/0xd0   el0_svc+0x14/0x4c   el0t_64_sync_handler+0x100/0x110   el0t_64_sync+0x15c/0x160  Code: d2800002 910092c0 52800023 f9800011 (885f7c01)  ---[ end trace 7e42dd9a39ed2281 ]---  Fix by using mt76_dev_phy() which will map band_idx to the correct phy for all hardware combinations.(CVE-2024-47715)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  wifi: rtw88: always wait for both firmware loading attempts  In &apos;rtw_wait_firmware_completion()&apos;, always wait for both (regular and wowlan) firmware loading attempts. Otherwise if &apos;rtw_usb_intf_init()&apos; has failed in &apos;rtw_usb_probe()&apos;, &apos;rtw_usb_disconnect()&apos; may issue &apos;ieee80211_free_hw()&apos; when one of &apos;rtw_load_firmware_cb()&apos; (usually the wowlan one) is still in progress, causing UAF detected by KASAN.(CVE-2024-47718)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  bonding: Fix unnecessary warnings and logs from bond_xdp_get_xmit_slave()  syzbot reported a WARNING in bond_xdp_get_xmit_slave. To reproduce this[1], one bond device (bond1) has xdpdrv, which increases bpf_master_redirect_enabled_key. Another bond device (bond0) which is unsupported by XDP but its slave (veth3) has xdpgeneric that returns XDP_TX. This triggers WARN_ON_ONCE() from the xdp_master_redirect(). To reduce unnecessary warnings and improve log management, we need to delete the WARN_ON_ONCE() and add ratelimit to the netdev_err().  [1] Steps to reproduce:     # Needs tx_xdp with return XDP_TX;     ip l add veth0 type veth peer veth1     ip l add veth3 type veth peer veth4     ip l add bond0 type bond mode 6 # BOND_MODE_ALB, unsupported by XDP     ip l add bond1 type bond # BOND_MODE_ROUNDROBIN by default     ip l set veth0 master bond1     ip l set bond1 up     # Increases bpf_master_redirect_enabled_key     ip l set dev bond1 xdpdrv object tx_xdp.o section xdp_tx     ip l set veth3 master bond0     ip l set bond0 up     ip l set veth4 up     # Triggers WARN_ON_ONCE() from the xdp_master_redirect()     ip l set veth3 xdpgeneric object tx_xdp.o section xdp_tx(CVE-2024-47734)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  f2fs: Require FMODE_WRITE for atomic write ioctls  The F2FS ioctls for starting and committing atomic writes check for inode_owner_or_capable(), but this does not give LSMs like SELinux or Landlock an opportunity to deny the write access - if the caller&apos;s FSUID matches the inode&apos;s UID, inode_owner_or_capable() immediately returns true.  There are scenarios where LSMs want to deny a process the ability to write particular files, even files that the FSUID of the process owns; but this can currently partially be bypassed using atomic write ioctls in two ways:   - F2FS_IOC_START_ATOMIC_REPLACE + F2FS_IOC_COMMIT_ATOMIC_WRITE can    truncate an inode to size 0  - F2FS_IOC_START_ATOMIC_WRITE + F2FS_IOC_ABORT_ATOMIC_WRITE can revert    changes another process concurrently made to a file  Fix it by requiring FMODE_WRITE for these operations, just like for F2FS_IOC_MOVE_RANGE. Since any legitimate caller should only be using these ioctls when intending to write into the file, that seems unlikely to break anything.(CVE-2024-47740)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  RDMA/hns: Fix Use-After-Free of rsv_qp on HIP08  Currently rsv_qp is freed before ib_unregister_device() is called on HIP08. During the time interval, users can still dereg MR and rsv_qp will be used in this process, leading to a UAF. Move the release of rsv_qp after calling ib_unregister_device() to fix it.(CVE-2024-47750)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  media: mediatek: vcodec: Fix H264 multi stateless decoder smatch warning  Fix a smatch static checker warning on vdec_h264_req_multi_if.c. Which leads to a kernel crash when fb is NULL.(CVE-2024-47754)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  tpm: Clean up TPM space after command failure  tpm_dev_transmit prepares the TPM space before attempting command transmission. However if the command fails no rollback of this preparation is done. This can result in transient handles being leaked if the device is subsequently closed with no further commands performed.  Fix this by flushing the space in the event of command transmission failure.(CVE-2024-49851)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  bpf: Fix helper writes to read-only maps  Lonial found an issue that despite user- and BPF-side frozen BPF map (like in case of .rodata), it was still possible to write into it from a BPF program side through specific helpers having ARG_PTR_TO_{LONG,INT} as arguments.  In check_func_arg() when the argument is as mentioned, the meta-&gt;raw_mode is never set. Later, check_helper_mem_access(), under the case of PTR_TO_MAP_VALUE as register base type, it assumes BPF_READ for the subsequent call to check_map_access_type() and given the BPF map is read-only it succeeds.  The helpers really need to be annotated as ARG_PTR_TO_{LONG,INT} | MEM_UNINIT when results are written into them as opposed to read out of them. The latter indicates that it&apos;s okay to pass a pointer to uninitialized memory as the memory is written to anyway.  However, ARG_PTR_TO_{LONG,INT} is a special case of ARG_PTR_TO_FIXED_SIZE_MEM just with additional alignment requirement. So it is better to just get rid of the ARG_PTR_TO_{LONG,INT} special cases altogether and reuse the fixed size memory types. For this, add MEM_ALIGNED to additionally ensure alignment given these helpers write directly into the args via *&lt;ptr&gt; = val. The .arg*_size has been initialized reflecting the actual sizeof(*&lt;ptr&gt;).  MEM_ALIGNED can only be used in combination with MEM_FIXED_SIZE annotated argument types, since in !MEM_FIXED_SIZE cases the verifier does not know the buffer size a priori and therefore cannot blindly write *&lt;ptr&gt; = val.(CVE-2024-49861)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  drm/amd/pm: ensure the fw_info is not null before using it  This resolves the dereference null return value warning reported by Coverity.(CVE-2024-49890)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  scsi: lpfc: Validate hdwq pointers before dereferencing in reset/errata paths  When the HBA is undergoing a reset or is handling an errata event, NULL ptr dereference crashes may occur in routines such as lpfc_sli_flush_io_rings(), lpfc_dev_loss_tmo_callbk(), or lpfc_abort_handler().  Add NULL ptr checks before dereferencing hdwq pointers that may have been freed due to operations colliding with a reset or errata event handler.(CVE-2024-49891)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Check null pointers before using dc-&gt;clk_mgr  [WHY &amp; HOW] dc-&gt;clk_mgr is null checked previously in the same function, indicating it might be null.  Passing &quot;dc&quot; to &quot;dc-&gt;hwss.apply_idle_power_optimizations&quot;, which dereferences null &quot;dc-&gt;clk_mgr&quot;. (The function pointer resolves to &quot;dcn35_apply_idle_power_optimizations&quot;.)  This fixes 1 FORWARD_NULL issue reported by Coverity.(CVE-2024-49907)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: avoid NULL pointer dereference  iwl_mvm_tx_skb_sta() and iwl_mvm_tx_mpdu() verify that the mvmvsta pointer is not NULL. It retrieves this pointer using iwl_mvm_sta_from_mac80211, which is dereferencing the ieee80211_sta pointer. If sta is NULL, iwl_mvm_sta_from_mac80211 will dereference a NULL pointer. Fix this by checking the sta pointer before retrieving the mvmsta from it. If sta is not NULL, then mvmsta isn&apos;t either.(CVE-2024-49929)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  aoe: fix the potential use-after-free problem in more places  For fixing CVE-2023-6270, f98364e92662 (&quot;aoe: fix the potential use-after-free problem in aoecmd_cfg_pkts&quot;) makes tx() calling dev_put() instead of doing in aoecmd_cfg_pkts(). It avoids that the tx() runs into use-after-free.  Then Nicolai Stange found more places in aoe have potential use-after-free problem with tx(). e.g. revalidate(), aoecmd_ata_rw(), resend(), probe() and aoecmd_cfg_rsp(). Those functions also use aoenet_xmit() to push packet to tx queue. So they should also use dev_hold() to increase the refcnt of skb-&gt;dev.  On the other hand, moving dev_put() to tx() causes that the refcnt of skb-&gt;dev be reduced to a negative value, because corresponding dev_hold() are not called in revalidate(), aoecmd_ata_rw(), resend(), probe(), and aoecmd_cfg_rsp(). This patch fixed this issue.(CVE-2024-49982)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  net/mlx5: Fix error path in multi-packet WQE transmit  Remove the erroneous unmap in case no DMA mapping was established  The multi-packet WQE transmit code attempts to obtain a DMA mapping for the skb. This could fail, e.g. under memory pressure, when the IOMMU driver just can&apos;t allocate more memory for page tables. While the code tries to handle this in the path below the err_unmap label it erroneously unmaps one entry from the sq&apos;s FIFO list of active mappings. Since the current map attempt failed this unmap is removing some random DMA mapping that might still be required. If the PCI function now presents that IOVA, the IOMMU may assumes a rogue DMA access and e.g. on s390 puts the PCI function in error state.  The erroneous behavior was seen in a stress-test environment that created memory pressure.(CVE-2024-50001)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  exec: don&apos;t WARN for racy path_noexec check  Both i_mode and noexec checks wrapped in WARN_ON stem from an artifact of the previous implementation. They used to legitimately check for the condition, but that got moved up in two commits: 633fb6ac3980 (&quot;exec: move S_ISREG() check earlier&quot;) 0fd338b2d2cd (&quot;exec: move path_noexec() check earlier&quot;)  Instead of being removed said checks are WARN_ON&apos;ed instead, which has some debug value.  However, the spurious path_noexec check is racy, resulting in unwarranted warnings should someone race with setting the noexec flag.  One can note there is more to perm-checking whether execve is allowed and none of the conditions are guaranteed to still hold after they were tested for.  Additionally this does not validate whether the code path did any perm checking to begin with -- it will pass if the inode happens to be regular.  Keep the redundant path_noexec() check even though it&apos;s mindless nonsense checking for guarantee that isn&apos;t given so drop the WARN.  Reword the commentary and do small tidy ups while here.  [brauner: keep redundant path_noexec() check](CVE-2024-50010)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  net: phy: Remove LED entry from LEDs list on unregister  Commit c938ab4da0eb (&quot;net: phy: Manual remove LEDs to ensure correct ordering&quot;) correctly fixed a problem with using devm_ but missed removing the LED entry from the LEDs list.  This cause kernel panic on specific scenario where the port for the PHY is torn down and up and the kmod for the PHY is removed.  On setting the port down the first time, the assosiacted LEDs are correctly unregistered. The associated kmod for the PHY is now removed. The kmod is now added again and the port is now put up, the associated LED are registered again. On putting the port down again for the second time after these step, the LED list now have 4 elements. With the first 2 already unregistered previously and the 2 new one registered again.  This cause a kernel panic as the first 2 element should have been removed.  Fix this by correctly removing the element when LED is unregistered.(CVE-2024-50023)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  Bluetooth: RFCOMM: FIX possible deadlock in rfcomm_sk_state_change  rfcomm_sk_state_change attempts to use sock_lock so it must never be called with it locked but rfcomm_sock_ioctl always attempt to lock it causing the following trace:  ====================================================== WARNING: possible circular locking dependency detected 6.8.0-syzkaller-08951-gfe46a7dd189e #0 Not tainted ------------------------------------------------------ syz-executor386/5093 is trying to acquire lock: ffff88807c396258 (sk_lock-AF_BLUETOOTH-BTPROTO_RFCOMM){+.+.}-{0:0}, at: lock_sock include/net/sock.h:1671 [inline] ffff88807c396258 (sk_lock-AF_BLUETOOTH-BTPROTO_RFCOMM){+.+.}-{0:0}, at: rfcomm_sk_state_change+0x5b/0x310 net/bluetooth/rfcomm/sock.c:73  but task is already holding lock: ffff88807badfd28 (&amp;d-&gt;lock){+.+.}-{3:3}, at: __rfcomm_dlc_close+0x226/0x6a0 net/bluetooth/rfcomm/core.c:491(CVE-2024-50044)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  fbcon: Fix a NULL pointer dereference issue in fbcon_putcs  syzbot has found a NULL pointer dereference bug in fbcon. Here is the simplified C reproducer:  struct param {  uint8_t type;  struct tiocl_selection ts; };  int main() {  struct fb_con2fbmap con2fb;  struct param param;   int fd = open(&quot;/dev/fb1&quot;, 0, 0);   con2fb.console = 0x19;  con2fb.framebuffer = 0;  ioctl(fd, FBIOPUT_CON2FBMAP, &amp;con2fb);   param.type = 2;  param.ts.xs = 0; param.ts.ys = 0;  param.ts.xe = 0; param.ts.ye = 0;  param.ts.sel_mode = 0;   int fd1 = open(&quot;/dev/tty1&quot;, O_RDWR, 0);  ioctl(fd1, TIOCLINUX, &amp;param);   con2fb.console = 1;  con2fb.framebuffer = 0;  ioctl(fd, FBIOPUT_CON2FBMAP, &amp;con2fb);   return 0; }  After calling ioctl(fd1, TIOCLINUX, &amp;param), the subsequent ioctl(fd, FBIOPUT_CON2FBMAP, &amp;con2fb) causes the kernel to follow a different execution path:   set_con2fb_map   -&gt; con2fb_init_display    -&gt; fbcon_set_disp     -&gt; redraw_screen      -&gt; hide_cursor       -&gt; clear_selection        -&gt; highlight         -&gt; invert_screen          -&gt; do_update_region           -&gt; fbcon_putcs            -&gt; ops-&gt;putcs  Since ops-&gt;putcs is a NULL pointer, this leads to a kernel panic. To prevent this, we need to call set_blitting_type() within set_con2fb_map() to properly initialize ops-&gt;putcs.(CVE-2024-50048)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  Bluetooth: Call iso_exit() on module unload  If iso_init() has been called, iso_exit() must be called on module unload. Without that, the struct proto that iso_init() registered with proto_register() becomes invalid, which could cause unpredictable problems later. In my case, with CONFIG_LIST_HARDENED and CONFIG_BUG_ON_DATA_CORRUPTION enabled, loading the module again usually triggers this BUG():    list_add corruption. next-&gt;prev should be prev (ffffffffb5355fd0),     but was 0000000000000068. (next=ffffffffc0a010d0).   ------------[ cut here ]------------   kernel BUG at lib/list_debug.c:29!   Oops: invalid opcode: 0000 [#1] PREEMPT SMP PTI   CPU: 1 PID: 4159 Comm: modprobe Not tainted 6.10.11-4+bt2-ao-desktop #1   RIP: 0010:__list_add_valid_or_report+0x61/0xa0   ...     __list_add_valid_or_report+0x61/0xa0     proto_register+0x299/0x320     hci_sock_init+0x16/0xc0 [bluetooth]     bt_init+0x68/0xd0 [bluetooth]     __pfx_bt_init+0x10/0x10 [bluetooth]     do_one_initcall+0x80/0x2f0     do_init_module+0x8b/0x230     __do_sys_init_module+0x15f/0x190     do_syscall_64+0x68/0x110   ...(CVE-2024-50078)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix user-after-free from session log off  There is racy issue between smb2 session log off and smb2 session setup. It will cause user-after-free from session log off. This add session_lock when setting SMB2_SESSION_EXPIRED and referece count to session struct not to free session while it is being used.(CVE-2024-50086)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  iommu/vt-d: Fix incorrect pci_for_each_dma_alias() for non-PCI devices  Previously, the domain_context_clear() function incorrectly called pci_for_each_dma_alias() to set up context entries for non-PCI devices. This could lead to kernel hangs or other unexpected behavior.  Add a check to only call pci_for_each_dma_alias() for PCI devices. For non-PCI devices, domain_context_clear_one() is called directly.(CVE-2024-50101)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  drm/amd/display: Disable PSR-SU on Parade 08-01 TCON too  Stuart Hayhurst has found that both at bootup and fullscreen VA-API video is leading to black screens for around 1 second and kernel WARNING [1] traces when calling dmub_psr_enable() with Parade 08-01 TCON.  These symptoms all go away with PSR-SU disabled for this TCON, so disable it for now while DMUB traces [2] from the failure can be analyzed and the failure state properly root caused.  (cherry picked from commit afb634a6823d8d9db23c5fb04f79c5549349628b)(CVE-2024-50108)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  net: sched: use RCU read-side critical section in taprio_dump()  Fix possible use-after-free in &apos;taprio_dump()&apos; by adding RCU read-side critical section there. Never seen on x86 but found on a KASAN-enabled arm64 system when investigating https://syzkaller.appspot.com/bug?extid=b65e0af58423fc8a73aa:  [T15862] BUG: KASAN: slab-use-after-free in taprio_dump+0xa0c/0xbb0 [T15862] Read of size 4 at addr ffff0000d4bb88f8 by task repro/15862 [T15862] [T15862] CPU: 0 UID: 0 PID: 15862 Comm: repro Not tainted 6.11.0-rc1-00293-gdefaf1a2113a-dirty #2 [T15862] Hardware name: QEMU QEMU Virtual Machine, BIOS edk2-20240524-5.fc40 05/24/2024 [T15862] Call trace: [T15862]  dump_backtrace+0x20c/0x220 [T15862]  show_stack+0x2c/0x40 [T15862]  dump_stack_lvl+0xf8/0x174 [T15862]  print_report+0x170/0x4d8 [T15862]  kasan_report+0xb8/0x1d4 [T15862]  __asan_report_load4_noabort+0x20/0x2c [T15862]  taprio_dump+0xa0c/0xbb0 [T15862]  tc_fill_qdisc+0x540/0x1020 [T15862]  qdisc_notify.isra.0+0x330/0x3a0 [T15862]  tc_modify_qdisc+0x7b8/0x1838 [T15862]  rtnetlink_rcv_msg+0x3c8/0xc20 [T15862]  netlink_rcv_skb+0x1f8/0x3d4 [T15862]  rtnetlink_rcv+0x28/0x40 [T15862]  netlink_unicast+0x51c/0x790 [T15862]  netlink_sendmsg+0x79c/0xc20 [T15862]  __sock_sendmsg+0xe0/0x1a0 [T15862]  ____sys_sendmsg+0x6c0/0x840 [T15862]  ___sys_sendmsg+0x1ac/0x1f0 [T15862]  __sys_sendmsg+0x110/0x1d0 [T15862]  __arm64_sys_sendmsg+0x74/0xb0 [T15862]  invoke_syscall+0x88/0x2e0 [T15862]  el0_svc_common.constprop.0+0xe4/0x2a0 [T15862]  do_el0_svc+0x44/0x60 [T15862]  el0_svc+0x50/0x184 [T15862]  el0t_64_sync_handler+0x120/0x12c [T15862]  el0t_64_sync+0x190/0x194 [T15862] [T15862] Allocated by task 15857: [T15862]  kasan_save_stack+0x3c/0x70 [T15862]  kasan_save_track+0x20/0x3c [T15862]  kasan_save_alloc_info+0x40/0x60 [T15862]  __kasan_kmalloc+0xd4/0xe0 [T15862]  __kmalloc_cache_noprof+0x194/0x334 [T15862]  taprio_change+0x45c/0x2fe0 [T15862]  tc_modify_qdisc+0x6a8/0x1838 [T15862]  rtnetlink_rcv_msg+0x3c8/0xc20 [T15862]  netlink_rcv_skb+0x1f8/0x3d4 [T15862]  rtnetlink_rcv+0x28/0x40 [T15862]  netlink_unicast+0x51c/0x790 [T15862]  netlink_sendmsg+0x79c/0xc20 [T15862]  __sock_sendmsg+0xe0/0x1a0 [T15862]  ____sys_sendmsg+0x6c0/0x840 [T15862]  ___sys_sendmsg+0x1ac/0x1f0 [T15862]  __sys_sendmsg+0x110/0x1d0 [T15862]  __arm64_sys_sendmsg+0x74/0xb0 [T15862]  invoke_syscall+0x88/0x2e0 [T15862]  el0_svc_common.constprop.0+0xe4/0x2a0 [T15862]  do_el0_svc+0x44/0x60 [T15862]  el0_svc+0x50/0x184 [T15862]  el0t_64_sync_handler+0x120/0x12c [T15862]  el0t_64_sync+0x190/0x194 [T15862] [T15862] Freed by task 6192: [T15862]  kasan_save_stack+0x3c/0x70 [T15862]  kasan_save_track+0x20/0x3c [T15862]  kasan_save_free_info+0x4c/0x80 [T15862]  poison_slab_object+0x110/0x160 [T15862]  __kasan_slab_free+0x3c/0x74 [T15862]  kfree+0x134/0x3c0 [T15862]  taprio_free_sched_cb+0x18c/0x220 [T15862]  rcu_core+0x920/0x1b7c [T15862]  rcu_core_si+0x10/0x1c [T15862]  handle_softirqs+0x2e8/0xd64 [T15862]  __do_softirq+0x14/0x20(CVE-2024-50126)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  net: sched: fix use-after-free in taprio_change()  In &apos;taprio_change()&apos;, &apos;admin&apos; pointer may become dangling due to sched switch / removal caused by &apos;advance_sched()&apos;, and critical section protected by &apos;q-&gt;current_entry_lock&apos; is too small to prevent from such a scenario (which causes use-after-free detected by KASAN). Fix this by prefer &apos;rcu_replace_pointer()&apos; over &apos;rcu_assign_pointer()&apos; to update &apos;admin&apos; immediately before an attempt to schedule freeing.(CVE-2024-50127)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  net: wwan: fix global oob in wwan_rtnl_policy  The variable wwan_rtnl_link_ops assign a *bigger* maxtype which leads to a global out-of-bounds read when parsing the netlink attributes. Exactly same bug cause as the oob fixed in commit b33fb5b801c6 (&quot;net: qualcomm: rmnet: fix global oob in rmnet_policy&quot;).  ================================================================== BUG: KASAN: global-out-of-bounds in validate_nla lib/nlattr.c:388 [inline] BUG: KASAN: global-out-of-bounds in __nla_validate_parse+0x19d7/0x29a0 lib/nlattr.c:603 Read of size 1 at addr ffffffff8b09cb60 by task syz.1.66276/323862  CPU: 0 PID: 323862 Comm: syz.1.66276 Not tainted 6.1.70 #1 Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014 Call Trace:  &lt;TASK&gt;  __dump_stack lib/dump_stack.c:88 [inline]  dump_stack_lvl+0x177/0x231 lib/dump_stack.c:106  print_address_description mm/kasan/report.c:284 [inline]  print_report+0x14f/0x750 mm/kasan/report.c:395  kasan_report+0x139/0x170 mm/kasan/report.c:495  validate_nla lib/nlattr.c:388 [inline]  __nla_validate_parse+0x19d7/0x29a0 lib/nlattr.c:603  __nla_parse+0x3c/0x50 lib/nlattr.c:700  nla_parse_nested_deprecated include/net/netlink.h:1269 [inline]  __rtnl_newlink net/core/rtnetlink.c:3514 [inline]  rtnl_newlink+0x7bc/0x1fd0 net/core/rtnetlink.c:3623  rtnetlink_rcv_msg+0x794/0xef0 net/core/rtnetlink.c:6122  netlink_rcv_skb+0x1de/0x420 net/netlink/af_netlink.c:2508  netlink_unicast_kernel net/netlink/af_netlink.c:1326 [inline]  netlink_unicast+0x74b/0x8c0 net/netlink/af_netlink.c:1352  netlink_sendmsg+0x882/0xb90 net/netlink/af_netlink.c:1874  sock_sendmsg_nosec net/socket.c:716 [inline]  __sock_sendmsg net/socket.c:728 [inline]  ____sys_sendmsg+0x5cc/0x8f0 net/socket.c:2499  ___sys_sendmsg+0x21c/0x290 net/socket.c:2553  __sys_sendmsg net/socket.c:2582 [inline]  __do_sys_sendmsg net/socket.c:2591 [inline]  __se_sys_sendmsg+0x19e/0x270 net/socket.c:2589  do_syscall_x64 arch/x86/entry/common.c:51 [inline]  do_syscall_64+0x45/0x90 arch/x86/entry/common.c:81  entry_SYSCALL_64_after_hwframe+0x63/0xcd RIP: 0033:0x7f67b19a24ad RSP: 002b:00007f67b17febb8 EFLAGS: 00000246 ORIG_RAX: 000000000000002e RAX: ffffffffffffffda RBX: 00007f67b1b45f80 RCX: 00007f67b19a24ad RDX: 0000000000000000 RSI: 0000000020005e40 RDI: 0000000000000004 RBP: 00007f67b1a1e01d R08: 0000000000000000 R09: 0000000000000000 R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 R13: 00007ffd2513764f R14: 00007ffd251376e0 R15: 00007f67b17fed40  &lt;/TASK&gt;  The buggy address belongs to the variable:  wwan_rtnl_policy+0x20/0x40  The buggy address belongs to the physical page: page:ffffea00002c2700 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0xb09c flags: 0xfff00000001000(reserved|node=0|zone=1|lastcpupid=0x7ff) raw: 00fff00000001000 ffffea00002c2708 ffffea00002c2708 0000000000000000 raw: 0000000000000000 0000000000000000 00000001ffffffff 0000000000000000 page dumped because: kasan: bad access detected page_owner info is not present (never set?)  Memory state around the buggy address:  ffffffff8b09ca00: 05 f9 f9 f9 05 f9 f9 f9 00 01 f9 f9 00 01 f9 f9  ffffffff8b09ca80: 00 00 00 05 f9 f9 f9 f9 00 00 03 f9 f9 f9 f9 f9 &gt;ffffffff8b09cb00: 00 00 00 00 05 f9 f9 f9 00 00 00 00 f9 f9 f9 f9                                                        ^  ffffffff8b09cb80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ==================================================================  According to the comment of `nla_parse_nested_deprecated`, use correct size `IFLA_WWAN_MAX` here to fix this issue.(CVE-2024-50128)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  netfilter: bpf: must hold reference on net namespace  BUG: KASAN: slab-use-after-free in __nf_unregister_net_hook+0x640/0x6b0 Read of size 8 at addr ffff8880106fe400 by task repro/72= bpf_nf_link_release+0xda/0x1e0 bpf_link_free+0x139/0x2d0 bpf_link_release+0x68/0x80 __fput+0x414/0xb60  Eric says:  It seems that bpf was able to defer the __nf_unregister_net_hook()  after exit()/close() time.  Perhaps a netns reference is missing, because the netns has been  dismantled/freed already.  bpf_nf_link_attach() does :  link-&gt;net = net;  But I do not see a reference being taken on net.  Add such a reference and release it after hook unreg. Note that I was unable to get syzbot reproducer to work, so I do not know if this resolves this splat.(CVE-2024-50130)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  nvme-pci: fix race condition between reset and nvme_dev_disable()  nvme_dev_disable() modifies the dev-&gt;online_queues field, therefore nvme_pci_update_nr_queues() should avoid racing against it, otherwise we could end up passing invalid values to blk_mq_update_nr_hw_queues().   WARNING: CPU: 39 PID: 61303 at drivers/pci/msi/api.c:347           pci_irq_get_affinity+0x187/0x210  Workqueue: nvme-reset-wq nvme_reset_work [nvme]  RIP: 0010:pci_irq_get_affinity+0x187/0x210  Call Trace:   &lt;TASK&gt;   ? blk_mq_pci_map_queues+0x87/0x3c0   ? pci_irq_get_affinity+0x187/0x210   blk_mq_pci_map_queues+0x87/0x3c0   nvme_pci_map_queues+0x189/0x460 [nvme]   blk_mq_update_nr_hw_queues+0x2a/0x40   nvme_reset_work+0x1be/0x2a0 [nvme]  Fix the bug by locking the shutdown_lock mutex before using dev-&gt;online_queues. Give up if nvme_dev_disable() is running or if it has been executed already.(CVE-2024-50135)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  reset: starfive: jh71x0: Fix accessing the empty member on JH7110 SoC  data-&gt;asserted will be NULL on JH7110 SoC since commit 82327b127d41 (&quot;reset: starfive: Add StarFive JH7110 reset driver&quot;) was added. Add the judgment condition to avoid errors when calling reset_control_status on JH7110 SoC.(CVE-2024-50137)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  KVM: arm64: Fix shift-out-of-bounds bug  Fix a shift-out-of-bounds bug reported by UBSAN when running VM with MTE enabled host kernel.  UBSAN: shift-out-of-bounds in arch/arm64/kvm/sys_regs.c:1988:14 shift exponent 33 is too large for 32-bit type &apos;int&apos; CPU: 26 UID: 0 PID: 7629 Comm: qemu-kvm Not tainted 6.12.0-rc2 #34 Hardware name: IEI NF5280R7/Mitchell MB, BIOS 00.00. 2024-10-12 09:28:54 10/14/2024 Call trace:  dump_backtrace+0xa0/0x128  show_stack+0x20/0x38  dump_stack_lvl+0x74/0x90  dump_stack+0x18/0x28  __ubsan_handle_shift_out_of_bounds+0xf8/0x1e0  reset_clidr+0x10c/0x1c8  kvm_reset_sys_regs+0x50/0x1c8  kvm_reset_vcpu+0xec/0x2b0  __kvm_vcpu_set_target+0x84/0x158  kvm_vcpu_set_target+0x138/0x168  kvm_arch_vcpu_ioctl_vcpu_init+0x40/0x2b0  kvm_arch_vcpu_ioctl+0x28c/0x4b8  kvm_vcpu_ioctl+0x4bc/0x7a8  __arm64_sys_ioctl+0xb4/0x100  invoke_syscall+0x70/0x100  el0_svc_common.constprop.0+0x48/0xf0  do_el0_svc+0x24/0x38  el0_svc+0x3c/0x158  el0t_64_sync_handler+0x120/0x130  el0t_64_sync+0x194/0x198(CVE-2024-50139)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  usb: typec: altmode should keep reference to parent  The altmode device release refers to its parent device, but without keeping a reference to it.  When registering the altmode, get a reference to the parent and put it in the release function.  Before this fix, when using CONFIG_DEBUG_KOBJECT_RELEASE, we see issues like this:  [   43.572860] kobject: &apos;port0.0&apos; (ffff8880057ba008): kobject_release, parent 0000000000000000 (delayed 3000) [   43.573532] kobject: &apos;port0.1&apos; (ffff8880057bd008): kobject_release, parent 0000000000000000 (delayed 1000) [   43.574407] kobject: &apos;port0&apos; (ffff8880057b9008): kobject_release, parent 0000000000000000 (delayed 3000) [   43.575059] kobject: &apos;port1.0&apos; (ffff8880057ca008): kobject_release, parent 0000000000000000 (delayed 4000) [   43.575908] kobject: &apos;port1.1&apos; (ffff8880057c9008): kobject_release, parent 0000000000000000 (delayed 4000) [   43.576908] kobject: &apos;typec&apos; (ffff8880062dbc00): kobject_release, parent 0000000000000000 (delayed 4000) [   43.577769] kobject: &apos;port1&apos; (ffff8880057bf008): kobject_release, parent 0000000000000000 (delayed 3000) [   46.612867] ================================================================== [   46.613402] BUG: KASAN: slab-use-after-free in typec_altmode_release+0x38/0x129 [   46.614003] Read of size 8 at addr ffff8880057b9118 by task kworker/2:1/48 [   46.614538] [   46.614668] CPU: 2 UID: 0 PID: 48 Comm: kworker/2:1 Not tainted 6.12.0-rc1-00138-gedbae730ad31 #535 [   46.615391] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS 1.15.0-1 04/01/2014 [   46.616042] Workqueue: events kobject_delayed_cleanup [   46.616446] Call Trace: [   46.616648]  &lt;TASK&gt; [   46.616820]  dump_stack_lvl+0x5b/0x7c [   46.617112]  ? typec_altmode_release+0x38/0x129 [   46.617470]  print_report+0x14c/0x49e [   46.617769]  ? rcu_read_unlock_sched+0x56/0x69 [   46.618117]  ? __virt_addr_valid+0x19a/0x1ab [   46.618456]  ? kmem_cache_debug_flags+0xc/0x1d [   46.618807]  ? typec_altmode_release+0x38/0x129 [   46.619161]  kasan_report+0x8d/0xb4 [   46.619447]  ? typec_altmode_release+0x38/0x129 [   46.619809]  ? process_scheduled_works+0x3cb/0x85f [   46.620185]  typec_altmode_release+0x38/0x129 [   46.620537]  ? process_scheduled_works+0x3cb/0x85f [   46.620907]  device_release+0xaf/0xf2 [   46.621206]  kobject_delayed_cleanup+0x13b/0x17a [   46.621584]  process_scheduled_works+0x4f6/0x85f [   46.621955]  ? __pfx_process_scheduled_works+0x10/0x10 [   46.622353]  ? hlock_class+0x31/0x9a [   46.622647]  ? lock_acquired+0x361/0x3c3 [   46.622956]  ? move_linked_works+0x46/0x7d [   46.623277]  worker_thread+0x1ce/0x291 [   46.623582]  ? __kthread_parkme+0xc8/0xdf [   46.623900]  ? __pfx_worker_thread+0x10/0x10 [   46.624236]  kthread+0x17e/0x190 [   46.624501]  ? kthread+0xfb/0x190 [   46.624756]  ? __pfx_kthread+0x10/0x10 [   46.625015]  ret_from_fork+0x20/0x40 [   46.625268]  ? __pfx_kthread+0x10/0x10 [   46.625532]  ret_from_fork_asm+0x1a/0x30 [   46.625805]  &lt;/TASK&gt; [   46.625953] [   46.626056] Allocated by task 678: [   46.626287]  kasan_save_stack+0x24/0x44 [   46.626555]  kasan_save_track+0x14/0x2d [   46.626811]  __kasan_kmalloc+0x3f/0x4d [   46.627049]  __kmalloc_noprof+0x1bf/0x1f0 [   46.627362]  typec_register_port+0x23/0x491 [   46.627698]  cros_typec_probe+0x634/0xbb6 [   46.628026]  platform_probe+0x47/0x8c [   46.628311]  really_probe+0x20a/0x47d [   46.628605]  device_driver_attach+0x39/0x72 [   46.628940]  bind_store+0x87/0xd7 [   46.629213]  kernfs_fop_write_iter+0x1aa/0x218 [   46.629574]  vfs_write+0x1d6/0x29b [   46.629856]  ksys_write+0xcd/0x13b [   46.630128]  do_syscall_64+0xd4/0x139 [   46.630420]  entry_SYSCALL_64_after_hwframe+0x76/0x7e [   46.630820] [   46.630946] Freed by task 48: [   46.631182]  kasan_save_stack+0x24/0x44 [   46.631493]  kasan_save_track+0x14/0x2d [   46.631799]  kasan_save_free_info+0x3f/0x4d [   46.632144]  __kasan_slab_free+0x37/0x45 [   46.632474] ---truncated---(CVE-2024-50150)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  netdevsim: use cond_resched() in nsim_dev_trap_report_work()  I am still seeing many syzbot reports hinting that syzbot might fool nsim_dev_trap_report_work() with hundreds of ports [1]  Lets use cond_resched(), and system_unbound_wq instead of implicit system_wq.  [1] INFO: task syz-executor:20633 blocked for more than 143 seconds.       Not tainted 6.12.0-rc2-syzkaller-00205-g1d227fcc7222 #0 &quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs&quot; disables this message. task:syz-executor    state:D stack:25856 pid:20633 tgid:20633 ppid:1      flags:0x00004006 ... NMI backtrace for cpu 1 CPU: 1 UID: 0 PID: 16760 Comm: kworker/1:0 Not tainted 6.12.0-rc2-syzkaller-00205-g1d227fcc7222 #0 Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 09/13/2024 Workqueue: events nsim_dev_trap_report_work  RIP: 0010:__sanitizer_cov_trace_pc+0x0/0x70 kernel/kcov.c:210 Code: 89 fb e8 23 00 00 00 48 8b 3d 04 fb 9c 0c 48 89 de 5b e9 c3 c7 5d 00 0f 1f 00 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 &lt;f3&gt; 0f 1e fa 48 8b 04 24 65 48 8b 0c 25 c0 d7 03 00 65 8b 15 60 f0 RSP: 0018:ffffc90000a187e8 EFLAGS: 00000246 RAX: 0000000000000100 RBX: ffffc90000a188e0 RCX: ffff888027d3bc00 RDX: ffff888027d3bc00 RSI: 0000000000000000 RDI: 0000000000000000 RBP: ffff88804a2e6000 R08: ffffffff8a4bc495 R09: ffffffff89da3577 R10: 0000000000000004 R11: ffffffff8a4bc2b0 R12: dffffc0000000000 R13: ffff88806573b503 R14: dffffc0000000000 R15: ffff8880663cca00 FS:  0000000000000000(0000) GS:ffff8880b8700000(0000) knlGS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007fc90a747f98 CR3: 000000000e734000 CR4: 00000000003526f0 DR0: 0000000000000000 DR1: 000000000000002b DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400 Call Trace:  &lt;NMI&gt;  &lt;/NMI&gt;  &lt;TASK&gt;   __local_bh_enable_ip+0x1bb/0x200 kernel/softirq.c:382   spin_unlock_bh include/linux/spinlock.h:396 [inline]   nsim_dev_trap_report drivers/net/netdevsim/dev.c:820 [inline]   nsim_dev_trap_report_work+0x75d/0xaa0 drivers/net/netdevsim/dev.c:850   process_one_work kernel/workqueue.c:3229 [inline]   process_scheduled_works+0xa63/0x1850 kernel/workqueue.c:3310   worker_thread+0x870/0xd30 kernel/workqueue.c:3391   kthread+0x2f0/0x390 kernel/kthread.c:389   ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147   ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  &lt;/TASK&gt;(CVE-2024-50155)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  RDMA/bnxt_re: Fix out of bound check  Driver exports pacing stats only on GenP5 and P7 adapters. But while parsing the pacing stats, driver has a check for &quot;rdev-&gt;dbr_pacing&quot;.  This caused a trace when KASAN is enabled.  BUG: KASAN: slab-out-of-bounds in bnxt_re_get_hw_stats+0x2b6a/0x2e00 [bnxt_re] Write of size 8 at addr ffff8885942a6340 by task modprobe/4809(CVE-2024-50158)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  bpf: Make sure internal and UAPI bpf_redirect flags don&apos;t overlap  The bpf_redirect_info is shared between the SKB and XDP redirect paths, and the two paths use the same numeric flag values in the ri-&gt;flags field (specifically, BPF_F_BROADCAST == BPF_F_NEXTHOP). This means that if skb bpf_redirect_neigh() is used with a non-NULL params argument and, subsequently, an XDP redirect is performed using the same bpf_redirect_info struct, the XDP path will get confused and end up crashing, which syzbot managed to trigger.  With the stack-allocated bpf_redirect_info, the structure is no longer shared between the SKB and XDP paths, so the crash doesn&apos;t happen anymore. However, different code paths using identically-numbered flag values in the same struct field still seems like a bit of a mess, so this patch cleans that up by moving the flag definitions together and redefining the three flags in BPF_F_REDIRECT_INTERNAL to not overlap with the flags used for XDP. It also adds a BUILD_BUG_ON() check to make sure the overlap is not re-introduced by mistake.(CVE-2024-50163)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  bpf: Fix overloading of MEM_UNINIT&apos;s meaning  Lonial reported an issue in the BPF verifier where check_mem_size_reg() has the following code:      if (!tnum_is_const(reg-&gt;var_off))         /* For unprivileged variable accesses, disable raw          * mode so that the program is required to          * initialize all the memory that the helper could          * just partially fill up.          */          meta = NULL;  This means that writes are not checked when the register containing the size of the passed buffer has not a fixed size. Through this bug, a BPF program can write to a map which is marked as read-only, for example, .rodata global maps.  The problem is that MEM_UNINIT&apos;s initial meaning that &quot;the passed buffer to the BPF helper does not need to be initialized&quot; which was added back in commit 435faee1aae9 (&quot;bpf, verifier: add ARG_PTR_TO_RAW_STACK type&quot;) got overloaded over time with &quot;the passed buffer is being written to&quot;.  The problem however is that checks such as the above which were added later via 06c1c049721a (&quot;bpf: allow helpers access to variable memory&quot;) set meta to NULL in order force the user to always initialize the passed buffer to the helper. Due to the current double meaning of MEM_UNINIT, this bypasses verifier write checks to the memory (not boundary checks though) and only assumes the latter memory is read instead.  Fix this by reverting MEM_UNINIT back to its original meaning, and having MEM_WRITE as an annotation to BPF helpers in order to then trigger the BPF verifier checks for writing to memory.  Some notes: check_arg_pair_ok() ensures that for ARG_CONST_SIZE{,_OR_ZERO} we can access fn-&gt;arg_type[arg - 1] since it must contain a preceding ARG_PTR_TO_MEM. For check_mem_reg() the meta argument can be removed altogether since we do check both BPF_READ and BPF_WRITE. Same for the equivalent check_kfunc_mem_size_reg().(CVE-2024-50164)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  drm/vc4: Stop the active perfmon before being destroyed  Upon closing the file descriptor, the active performance monitor is not stopped. Although all perfmons are destroyed in `vc4_perfmon_close_file()`, the active performance monitor&apos;s pointer (`vc4-&gt;active_perfmon`) is still retained.  If we open a new file descriptor and submit a few jobs with performance monitors, the driver will attempt to stop the active performance monitor using the stale pointer in `vc4-&gt;active_perfmon`. However, this pointer is no longer valid because the previous process has already terminated, and all performance monitors associated with it have been destroyed and freed.  To fix this, when the active performance monitor belongs to a given process, explicitly stop it before destroying and freeing it.(CVE-2024-50187)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  net: phy: dp83869: fix memory corruption when enabling fiber  When configuring the fiber port, the DP83869 PHY driver incorrectly calls linkmode_set_bit() with a bit mask (1 &lt;&lt; 10) rather than a bit number (10). This corrupts some other memory location -- in case of arm64 the priv pointer in the same structure.  Since the advertising flags are updated from supported at the end of the function the incorrect line isn&apos;t needed at all and can be removed.(CVE-2024-50188)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  pinctrl: ocelot: fix system hang on level based interrupts  The current implementation only calls chained_irq_enter() and chained_irq_exit() if it detects pending interrupts.  ``` for (i = 0; i &lt; info-&gt;stride; i++) {  uregmap_read(info-&gt;map, id_reg + 4 * i, &amp;reg);  if (!reg)   continue;   chained_irq_enter(parent_chip, desc); ```  However, in case of GPIO pin configured in level mode and the parent controller configured in edge mode, GPIO interrupt might be lowered by the hardware. In the result, if the interrupt is short enough, the parent interrupt is still pending while the GPIO interrupt is cleared; chained_irq_enter() never gets called and the system hangs trying to service the parent interrupt.  Moving chained_irq_enter() and chained_irq_exit() outside the for loop ensures that they are called even when GPIO interrupt is lowered by the hardware.  The similar code with chained_irq_enter() / chained_irq_exit() functions wrapping interrupt checking loop may be found in many other drivers: ``` grep -r -A 10 chained_irq_enter drivers/pinctrl ```(CVE-2024-50196)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  drm/radeon: Fix encoder-&gt;possible_clones  Include the encoder itself in its possible_clones bitmask. In the past nothing validated that drivers were populating possible_clones correctly, but that changed in commit 74d2aacbe840 (&quot;drm: Validate encoder-&gt;possible_clones&quot;). Looks like radeon never got the memo and is still not following the rules 100% correctly.  This results in some warnings during driver initialization: Bogus possible_clones: [ENCODER:46:TV-46] possible_clones=0x4 (full encoder mask=0x7) WARNING: CPU: 0 PID: 170 at drivers/gpu/drm/drm_mode_config.c:615 drm_mode_config_validate+0x113/0x39c ...  (cherry picked from commit 3b6e7d40649c0d75572039aff9d0911864c689db)(CVE-2024-50201)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  udf: refactor inode_bmap() to handle error  Refactor inode_bmap() to handle error since udf_next_aext() can return error now. On situations like ftruncate, udf_extend_file() can now detect errors and bail out early without resorting to checking for particular offsets and assuming internal behavior of these functions.(CVE-2024-50211)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ocfs2: pass u64 to ocfs2_truncate_inline maybe overflow  Syzbot reported a kernel BUG in ocfs2_truncate_inline.  There are two reasons for this: first, the parameter value passed is greater than ocfs2_max_inline_data_with_xattr, second, the start and end parameters of ocfs2_truncate_inline are &quot;unsigned int&quot;.  So, we need to add a sanity check for byte_start and byte_len right before ocfs2_truncate_inline() in ocfs2_remove_inode_range(), if they are greater than ocfs2_max_inline_data_with_xattr return -EINVAL.(CVE-2024-50218)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  iov_iter: fix copy_page_from_iter_atomic() if KMAP_LOCAL_FORCE_MAP  generic/077 on x86_32 CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP=y with highmem, on huge=always tmpfs, issues a warning and then hangs (interruptibly):  WARNING: CPU: 5 PID: 3517 at mm/highmem.c:622 kunmap_local_indexed+0x62/0xc9 CPU: 5 UID: 0 PID: 3517 Comm: cp Not tainted 6.12.0-rc4 #2 ... copy_page_from_iter_atomic+0xa6/0x5ec generic_perform_write+0xf6/0x1b4 shmem_file_write_iter+0x54/0x67  Fix copy_page_from_iter_atomic() by limiting it in that case (include/linux/skbuff.h skb_frag_must_loop() does similar).  But going forward, perhaps CONFIG_DEBUG_KMAP_LOCAL_FORCE_MAP is too surprising, has outlived its usefulness, and should just be removed?(CVE-2024-50222)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  cxl/port: Fix use-after-free, permit out-of-order decoder shutdown  In support of investigating an initialization failure report [1], cxl_test was updated to register mock memory-devices after the mock root-port/bus device had been registered. That led to cxl_test crashing with a use-after-free bug with the following signature:      cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem0:decoder7.0 @ 0 next: cxl_switch_uport.0 nr_eps: 1 nr_targets: 1     cxl_port_attach_region: cxl region3: cxl_host_bridge.0:port3 decoder3.0 add: mem4:decoder14.0 @ 1 next: cxl_switch_uport.0 nr_eps: 2 nr_targets: 1     cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[0] = cxl_switch_dport.0 for mem0:decoder7.0 @ 0 1)  cxl_port_setup_targets: cxl region3: cxl_switch_uport.0:port6 target[1] = cxl_switch_dport.4 for mem4:decoder14.0 @ 1     [..]     cxld_unregister: cxl decoder14.0:     cxl_region_decode_reset: cxl_region region3:     mock_decoder_reset: cxl_port port3: decoder3.0 reset 2)  mock_decoder_reset: cxl_port port3: decoder3.0: out of order reset, expected decoder3.1     cxl_endpoint_decoder_release: cxl decoder14.0:     [..]     cxld_unregister: cxl decoder7.0: 3)  cxl_region_decode_reset: cxl_region region3:     Oops: general protection fault, probably for non-canonical address 0x6b6b6b6b6b6b6bc3: 0000 [#1] PREEMPT SMP PTI     [..]     RIP: 0010:to_cxl_port+0x8/0x60 [cxl_core]     [..]     Call Trace:      &lt;TASK&gt;      cxl_region_decode_reset+0x69/0x190 [cxl_core]      cxl_region_detach+0xe8/0x210 [cxl_core]      cxl_decoder_kill_region+0x27/0x40 [cxl_core]      cxld_unregister+0x5d/0x60 [cxl_core]  At 1) a region has been established with 2 endpoint decoders (7.0 and 14.0). Those endpoints share a common switch-decoder in the topology (3.0). At teardown, 2), decoder14.0 is the first to be removed and hits the &quot;out of order reset case&quot; in the switch decoder. The effect though is that region3 cleanup is aborted leaving it in-tact and referencing decoder14.0. At 3) the second attempt to teardown region3 trips over the stale decoder14.0 object which has long since been deleted.  The fix here is to recognize that the CXL specification places no mandate on in-order shutdown of switch-decoders, the driver enforces in-order allocation, and hardware enforces in-order commit. So, rather than fail and leave objects dangling, always remove them.  In support of making cxl_region_decode_reset() always succeed, cxl_region_invalidate_memregion() failures are turned into warnings. Crashing the kernel is ok there since system integrity is at risk if caches cannot be managed around physical address mutation events like CXL region destruction.  A new device_for_each_child_reverse_from() is added to cleanup port-&gt;commit_end after all dependent decoders have been disabled. In other words if decoders are allocated 0-&gt;1-&gt;2 and disabled 1-&gt;2-&gt;0 then port-&gt;commit_end only decrements from 2 after 2 has been disabled, and it decrements all the way to zero since 1 was disabled previously.(CVE-2024-50226)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  nilfs2: fix potential deadlock with newly created symlinks  Syzbot reported that page_symlink(), called by nilfs_symlink(), triggers memory reclamation involving the filesystem layer, which can result in circular lock dependencies among the reader/writer semaphore nilfs-&gt;ns_segctor_sem, s_writers percpu_rwsem (intwrite) and the fs_reclaim pseudo lock.  This is because after commit 21fc61c73c39 (&quot;don&apos;t put symlink bodies in pagecache into highmem&quot;), the gfp flags of the page cache for symbolic links are overwritten to GFP_KERNEL via inode_nohighmem().  This is not a problem for symlinks read from the backing device, because the __GFP_FS flag is dropped after inode_nohighmem() is called.  However, when a new symlink is created with nilfs_symlink(), the gfp flags remain overwritten to GFP_KERNEL.  Then, memory allocation called from page_symlink() etc.  triggers memory reclamation including the FS layer, which may call nilfs_evict_inode() or nilfs_dirty_inode().  And these can cause a deadlock if they are called while nilfs-&gt;ns_segctor_sem is held:  Fix this issue by dropping the __GFP_FS flag from the page cache GFP flags of newly created symlinks in the same way that nilfs_new_inode() and __nilfs_read_inode() do, as a workaround until we adopt nofs allocation scope consistently or improve the locking constraints.(CVE-2024-50229)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  wifi: cfg80211: clear wdev-&gt;cqm_config pointer on free  When we free wdev-&gt;cqm_config when unregistering, we also need to clear out the pointer since the same wdev/netdev may get re-registered in another network namespace, then destroyed later, running this code again, which results in a double-free.(CVE-2024-50235)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  netdevsim: Add trailing zero to terminate the string in nsim_nexthop_bucket_activity_write()  This was found by a static analyzer. We should not forget the trailing zero after copy_from_user() if we will further do some string operations, sscanf() in this case. Adding a trailing zero will ensure that the function performs properly.(CVE-2024-50259)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  macsec: Fix use-after-free while sending the offloading packet  KASAN reports the following UAF. The metadata_dst, which is used to store the SCI value for macsec offload, is already freed by metadata_dst_free() in macsec_free_netdev(), while driver still use it for sending the packet.  To fix this issue, dst_release() is used instead to release metadata_dst. So it is not freed instantly in macsec_free_netdev() if still referenced by skb.   BUG: KASAN: slab-use-after-free in mlx5e_xmit+0x1e8f/0x4190 [mlx5_core]  Read of size 2 at addr ffff88813e42e038 by task kworker/7:2/714  [...]  Workqueue: mld mld_ifc_work  Call Trace:   &lt;TASK&gt;   dump_stack_lvl+0x51/0x60   print_report+0xc1/0x600   kasan_report+0xab/0xe0   mlx5e_xmit+0x1e8f/0x4190 [mlx5_core]   dev_hard_start_xmit+0x120/0x530   sch_direct_xmit+0x149/0x11e0   __qdisc_run+0x3ad/0x1730   __dev_queue_xmit+0x1196/0x2ed0   vlan_dev_hard_start_xmit+0x32e/0x510 [8021q]   dev_hard_start_xmit+0x120/0x530   __dev_queue_xmit+0x14a7/0x2ed0   macsec_start_xmit+0x13e9/0x2340   dev_hard_start_xmit+0x120/0x530   __dev_queue_xmit+0x14a7/0x2ed0   ip6_finish_output2+0x923/0x1a70   ip6_finish_output+0x2d7/0x970   ip6_output+0x1ce/0x3a0   NF_HOOK.constprop.0+0x15f/0x190   mld_sendpack+0x59a/0xbd0   mld_ifc_work+0x48a/0xa80   process_one_work+0x5aa/0xe50   worker_thread+0x79c/0x1290   kthread+0x28f/0x350   ret_from_fork+0x2d/0x70   ret_from_fork_asm+0x11/0x20   &lt;/TASK&gt;   Allocated by task 3922:   kasan_save_stack+0x20/0x40   kasan_save_track+0x10/0x30   __kasan_kmalloc+0x77/0x90   __kmalloc_noprof+0x188/0x400   metadata_dst_alloc+0x1f/0x4e0   macsec_newlink+0x914/0x1410   __rtnl_newlink+0xe08/0x15b0   rtnl_newlink+0x5f/0x90   rtnetlink_rcv_msg+0x667/0xa80   netlink_rcv_skb+0x12c/0x360   netlink_unicast+0x551/0x770   netlink_sendmsg+0x72d/0xbd0   __sock_sendmsg+0xc5/0x190   ____sys_sendmsg+0x52e/0x6a0   ___sys_sendmsg+0xeb/0x170   __sys_sendmsg+0xb5/0x140   do_syscall_64+0x4c/0x100   entry_SYSCALL_64_after_hwframe+0x4b/0x53   Freed by task 4011:   kasan_save_stack+0x20/0x40   kasan_save_track+0x10/0x30   kasan_save_free_info+0x37/0x50   poison_slab_object+0x10c/0x190   __kasan_slab_free+0x11/0x30   kfree+0xe0/0x290   macsec_free_netdev+0x3f/0x140   netdev_run_todo+0x450/0xc70   rtnetlink_rcv_msg+0x66f/0xa80   netlink_rcv_skb+0x12c/0x360   netlink_unicast+0x551/0x770   netlink_sendmsg+0x72d/0xbd0   __sock_sendmsg+0xc5/0x190   ____sys_sendmsg+0x52e/0x6a0   ___sys_sendmsg+0xeb/0x170   __sys_sendmsg+0xb5/0x140   do_syscall_64+0x4c/0x100   entry_SYSCALL_64_after_hwframe+0x4b/0x53(CVE-2024-50261)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  vsock/virtio: Initialization of the dangling pointer occurring in vsk-&gt;trans  During loopback communication, a dangling pointer can be created in vsk-&gt;trans, potentially leading to a Use-After-Free condition.  This issue is resolved by initializing vsk-&gt;trans to NULL.(CVE-2024-50264)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  dm cache: fix potential out-of-bounds access on the first resume  Out-of-bounds access occurs if the fast device is expanded unexpectedly before the first-time resume of the cache table. This happens because expanding the fast device requires reloading the cache table for cache_create to allocate new in-core data structures that fit the new size, and the check in cache_preresume is not performed during the first resume, leading to the issue.  Reproduce steps:  1. prepare component devices:  dmsetup create cmeta --table &quot;0 8192 linear /dev/sdc 0&quot; dmsetup create cdata --table &quot;0 65536 linear /dev/sdc 8192&quot; dmsetup create corig --table &quot;0 524288 linear /dev/sdc 262144&quot; dd if=/dev/zero of=/dev/mapper/cmeta bs=4k count=1 oflag=direct  2. load a cache table of 512 cache blocks, and deliberately expand the    fast device before resuming the cache, making the in-core data    structures inadequate.  dmsetup create cache --notable dmsetup reload cache --table &quot;0 524288 cache /dev/mapper/cmeta \\ /dev/mapper/cdata /dev/mapper/corig 128 2 metadata2 writethrough smq 0&quot; dmsetup reload cdata --table &quot;0 131072 linear /dev/sdc 8192&quot; dmsetup resume cdata dmsetup resume cache  3. suspend the cache to write out the in-core dirty bitset and hint    array, leading to out-of-bounds access to the dirty bitset at offset    0x40:  dmsetup suspend cache  KASAN reports:    BUG: KASAN: vmalloc-out-of-bounds in is_dirty_callback+0x2b/0x80   Read of size 8 at addr ffffc90000085040 by task dmsetup/90    (...snip...)   The buggy address belongs to the virtual mapping at    [ffffc90000085000, ffffc90000087000) created by:    cache_ctr+0x176a/0x35f0    (...snip...)   Memory state around the buggy address:    ffffc90000084f00: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8    ffffc90000084f80: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8   &gt;ffffc90000085000: 00 00 00 00 00 00 00 00 f8 f8 f8 f8 f8 f8 f8 f8                                              ^    ffffc90000085080: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8    ffffc90000085100: f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8 f8  Fix by checking the size change on the first resume.(CVE-2024-50278)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: add missing size check in amdgpu_debugfs_gprwave_read()  Avoid a possible buffer overflow if size is larger than 4K.  (cherry picked from commit f5d873f5825b40d886d03bd2aede91d4cf002434)(CVE-2024-50282)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ksmbd: check outstanding simultaneous SMB operations  If Client send simultaneous SMB operations to ksmbd, It exhausts too much memory through the &quot;ksmbd_work_cache\u201d. It will cause OOM issue. ksmbd has a credit mechanism but it can&apos;t handle this problem. This patch add the check if it exceeds max credits to prevent this problem by assuming that one smb request consumes at least one credit.(CVE-2024-50285)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ksmbd: fix slab-use-after-free in ksmbd_smb2_session_create  There is a race condition between ksmbd_smb2_session_create and ksmbd_expire_session. This patch add missing sessions_table_lock while adding/deleting session from global session table.(CVE-2024-50286)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  regulator: rtq2208: Fix uninitialized use of regulator_config  Fix rtq2208 driver uninitialized use to cause kernel error.(CVE-2024-50300)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  ipv4: ip_tunnel: Fix suspicious RCU usage warning in ip_tunnel_init_flow()  There are code paths from which the function is called without holding the RCU read lock, resulting in a suspicious RCU usage warning [1].  Fix by using l3mdev_master_upper_ifindex_by_index() which will acquire the RCU read lock before calling l3mdev_master_upper_ifindex_by_index_rcu().  [1] WARNING: suspicious RCU usage 6.12.0-rc3-custom-gac8f72681cf2 #141 Not tainted ----------------------------- net/core/dev.c:876 RCU-list traversed in non-reader section!!  other info that might help us debug this:  rcu_scheduler_active = 2, debug_locks = 1 1 lock held by ip/361:  #0: ffffffff86fc7cb0 (rtnl_mutex){+.+.}-{3:3}, at: rtnetlink_rcv_msg+0x377/0xf60  stack backtrace: CPU: 3 UID: 0 PID: 361 Comm: ip Not tainted 6.12.0-rc3-custom-gac8f72681cf2 #141 Hardware name: Bochs Bochs, BIOS Bochs 01/01/2011 Call Trace:  &lt;TASK&gt;  dump_stack_lvl+0xba/0x110  lockdep_rcu_suspicious.cold+0x4f/0xd6  dev_get_by_index_rcu+0x1d3/0x210  l3mdev_master_upper_ifindex_by_index_rcu+0x2b/0xf0  ip_tunnel_bind_dev+0x72f/0xa00  ip_tunnel_newlink+0x368/0x7a0  ipgre_newlink+0x14c/0x170  __rtnl_newlink+0x1173/0x19c0  rtnl_newlink+0x6c/0xa0  rtnetlink_rcv_msg+0x3cc/0xf60  netlink_rcv_skb+0x171/0x450  netlink_unicast+0x539/0x7f0  netlink_sendmsg+0x8c1/0xd80  ____sys_sendmsg+0x8f9/0xc20  ___sys_sendmsg+0x197/0x1e0  __sys_sendmsg+0x122/0x1f0  do_syscall_64+0xbb/0x1d0  entry_SYSCALL_64_after_hwframe+0x77/0x7f(CVE-2024-53042)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  wifi: iwlwifi: mvm: Fix response handling in iwl_mvm_send_recovery_cmd()  1. The size of the response packet is not validated. 2. The response buffer is not freed.  Resolve these issues by switching to iwl_mvm_send_cmd_status(), which handles both size validation and frees the buffer.(CVE-2024-53059)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  drm/amdgpu: prevent NULL pointer dereference if ATIF is not supported  acpi_evaluate_object() may return AE_NOT_FOUND (failure), which would result in dereferencing buffer.pointer (obj) while being NULL.  Although this case may be unrealistic for the current code, it is still better to protect against possible bugs.  Bail out also when status is AE_NOT_FOUND.  This fixes 1 FORWARD_NULL issue reported by Coverity Report: CID 1600951:  Null pointer dereferences  (FORWARD_NULL)  (cherry picked from commit 91c9e221fe2553edf2db71627d8453f083de87a1)(CVE-2024-53060)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  NFSD: Never decrement pending_async_copies on error  The error flow in nfsd4_copy() calls cleanup_async_copy(), which already decrements nn-&gt;pending_async_copies.(CVE-2024-53073)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:  afs: Fix lock recursion  afs_wake_up_async_call() can incur lock recursion.  The problem is that it is called from AF_RXRPC whilst holding the -&gt;notify_lock, but it tries to take a ref on the afs_call struct in order to pass it to a work queue - but if the afs_call is already queued, we then have an extraneous ref that must be put... calling afs_put_call() may call back down into AF_RXRPC through rxrpc_kernel_shutdown_call(), however, which might try taking the -&gt;notify_lock again.  This case isn&apos;t very common, however, so defer it to a workqueue.  The oops looks something like:    BUG: spinlock recursion on CPU#0, krxrpcio/7001/1646    lock: 0xffff888141399b30, .magic: dead4ead, .owner: krxrpcio/7001/1646, .owner_cpu: 0   CPU: 0 UID: 0 PID: 1646 Comm: krxrpcio/7001 Not tainted 6.12.0-rc2-build3+ #4351   Hardware name: ASUS All Series/H97-PLUS, BIOS 2306 10/09/2014   Call Trace:    &lt;TASK&gt;    dump_stack_lvl+0x47/0x70    do_raw_spin_lock+0x3c/0x90    rxrpc_kernel_shutdown_call+0x83/0xb0    afs_put_call+0xd7/0x180    rxrpc_notify_socket+0xa0/0x190    rxrpc_input_split_jumbo+0x198/0x1d0    rxrpc_input_data+0x14b/0x1e0    ? rxrpc_input_call_packet+0xc2/0x1f0    rxrpc_input_call_event+0xad/0x6b0    rxrpc_input_packet_on_conn+0x1e1/0x210    rxrpc_input_packet+0x3f2/0x4d0    rxrpc_io_thread+0x243/0x410    ? __pfx_rxrpc_io_thread+0x10/0x10    kthread+0xcf/0xe0    ? __pfx_kthread+0x10/0x10    ret_from_fork+0x24/0x40    ? __pfx_kthread+0x10/0x10    ret_from_fork_asm+0x1a/0x30    &lt;/TASK&gt;(CVE-2024-53090)",
  "id": "OESA-2024-2522",
  "modified": "2025-09-03T06:20:24.401108Z",
  "published": "2024-12-06T15:25:55Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2024-2522"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-39483"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-44950"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-45026"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46808"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46813"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-46825"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47682"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47706"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47714"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47715"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47718"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47734"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47740"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47750"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-47754"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49851"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49861"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49890"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49891"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49907"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49929"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-49982"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50001"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50010"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50023"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50044"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50048"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50078"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50086"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50101"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50108"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50126"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50127"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50128"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50130"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50135"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50137"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50139"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50150"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50155"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50158"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50163"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50164"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50187"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50188"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50196"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50201"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50211"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50218"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50222"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50226"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50229"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50235"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50259"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50261"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50264"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50278"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50282"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50285"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50286"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-50300"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53042"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53059"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53060"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53073"
    },
    {
      "type": "ADVISORY",
      "url": "https://nvd.nist.gov/vuln/detail/CVE-2024-53090"
    }
  ],
  "schema_version": "1.7.3",
  "summary": "kernel security update",
  "upstream": [
    "CVE-2024-39483",
    "CVE-2024-44950",
    "CVE-2024-45026",
    "CVE-2024-46808",
    "CVE-2024-46813",
    "CVE-2024-46825",
    "CVE-2024-47682",
    "CVE-2024-47706",
    "CVE-2024-47714",
    "CVE-2024-47715",
    "CVE-2024-47718",
    "CVE-2024-47734",
    "CVE-2024-47740",
    "CVE-2024-47750",
    "CVE-2024-47754",
    "CVE-2024-49851",
    "CVE-2024-49861",
    "CVE-2024-49890",
    "CVE-2024-49891",
    "CVE-2024-49907",
    "CVE-2024-49929",
    "CVE-2024-49982",
    "CVE-2024-50001",
    "CVE-2024-50010",
    "CVE-2024-50023",
    "CVE-2024-50044",
    "CVE-2024-50048",
    "CVE-2024-50078",
    "CVE-2024-50086",
    "CVE-2024-50101",
    "CVE-2024-50108",
    "CVE-2024-50126",
    "CVE-2024-50127",
    "CVE-2024-50128",
    "CVE-2024-50130",
    "CVE-2024-50135",
    "CVE-2024-50137",
    "CVE-2024-50139",
    "CVE-2024-50150",
    "CVE-2024-50155",
    "CVE-2024-50158",
    "CVE-2024-50163",
    "CVE-2024-50164",
    "CVE-2024-50187",
    "CVE-2024-50188",
    "CVE-2024-50196",
    "CVE-2024-50201",
    "CVE-2024-50211",
    "CVE-2024-50218",
    "CVE-2024-50222",
    "CVE-2024-50226",
    "CVE-2024-50229",
    "CVE-2024-50235",
    "CVE-2024-50259",
    "CVE-2024-50261",
    "CVE-2024-50264",
    "CVE-2024-50278",
    "CVE-2024-50282",
    "CVE-2024-50285",
    "CVE-2024-50286",
    "CVE-2024-50300",
    "CVE-2024-53042",
    "CVE-2024-53059",
    "CVE-2024-53060",
    "CVE-2024-53073",
    "CVE-2024-53090"
  ]
}