{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2025-38261.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.16.3-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "6.12.38-1",
        "6.12.41-1",
        "6.12.43-1",
        "6.12.43-1~bpo12+1",
        "6.12.48-1",
        "6.13.10-1~exp1",
        "6.13.11-1~exp1",
        "6.13.2-1~exp1",
        "6.13.3-1~exp1",
        "6.13.4-1~exp1",
        "6.13.5-1~exp1",
        "6.13.6-1~exp1",
        "6.13.7-1~exp1",
        "6.13.8-1~exp1",
        "6.13.9-1~exp1",
        "6.13~rc6-1~exp1",
        "6.13~rc7-1~exp1",
        "6.14.3-1~exp1",
        "6.14.5-1~exp1",
        "6.14.6-1~exp1",
        "6.15-1~exp1",
        "6.15.1-1~exp1",
        "6.15.2-1~exp1",
        "6.15.3-1~exp1",
        "6.15.4-1~exp1",
        "6.15.5-1~exp1",
        "6.15.6-1~exp1",
        "6.15~rc7-1~exp1",
        "6.16-1~exp1",
        "6.16.1-1~exp1",
        "6.16.3-1~bpo13+1",
        "6.16~rc7-1~exp1"
      ]
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  riscv: save the SR_SUM status over switches  When threads/tasks are switched we need to ensure the old execution's SR_SUM state is saved and the new thread has the old SR_SUM state restored.  The issue was seen under heavy load especially with the syz-stress tool running, with crashes as follows in schedule_tail:  Unable to handle kernel access to user memory without uaccess routines at virtual address 000000002749f0d0 Oops [#1] Modules linked in: CPU: 1 PID: 4875 Comm: syz-executor.0 Not tainted 5.12.0-rc2-syzkaller-00467-g0d7588ab9ef9 #0 Hardware name: riscv-virtio,qemu (DT) epc : schedule_tail+0x72/0xb2 kernel/sched/core.c:4264  ra : task_pid_vnr include/linux/sched.h:1421 [inline]  ra : schedule_tail+0x70/0xb2 kernel/sched/core.c:4264 epc : ffffffe00008c8b0 ra : ffffffe00008c8ae sp : ffffffe025d17ec0  gp : ffffffe005d25378 tp : ffffffe00f0d0000 t0 : 0000000000000000  t1 : 0000000000000001 t2 : 00000000000f4240 s0 : ffffffe025d17ee0  s1 : 000000002749f0d0 a0 : 000000000000002a a1 : 0000000000000003  a2 : 1ffffffc0cfac500 a3 : ffffffe0000c80cc a4 : 5ae9db91c19bbe00  a5 : 0000000000000000 a6 : 0000000000f00000 a7 : ffffffe000082eba  s2 : 0000000000040000 s3 : ffffffe00eef96c0 s4 : ffffffe022c77fe0  s5 : 0000000000004000 s6 : ffffffe067d74e00 s7 : ffffffe067d74850  s8 : ffffffe067d73e18 s9 : ffffffe067d74e00 s10: ffffffe00eef96e8  s11: 000000ae6cdf8368 t3 : 5ae9db91c19bbe00 t4 : ffffffc4043cafb2  t5 : ffffffc4043cafba t6 : 0000000000040000 status: 0000000000000120 badaddr: 000000002749f0d0 cause: 000000000000000f Call Trace: [<ffffffe00008c8b0>] schedule_tail+0x72/0xb2 kernel/sched/core.c:4264 [<ffffffe000005570>] ret_from_exception+0x0/0x14 Dumping ftrace buffer:    (ftrace buffer empty) ---[ end trace b5f8f9231dc87dda ]---  The issue comes from the put_user() in schedule_tail (kernel/sched/core.c) doing the following:  asmlinkage __visible void schedule_tail(struct task_struct *prev) { ...         if (current->set_child_tid)                 put_user(task_pid_vnr(current), current->set_child_tid); ... }  the put_user() macro causes the code sequence to come out as follows:  1:\t__enable_user_access() 2:\treg = task_pid_vnr(current); 3:\t*current->set_child_tid = reg; 4:\t__disable_user_access()  The problem is that we may have a sleeping function as argument which could clear SR_SUM causing the panic above. This was fixed by evaluating the argument of the put_user() macro outside the user-enabled section in commit 285a76bb2cf5 (\"riscv: evaluate put_user() arg before enabling user access\")\"  In order for riscv to take advantage of unsafe_get/put_XXX() macros and to avoid the same issue we had with put_user() and sleeping functions we must ensure code flow can go through switch_to() from within a region of code with SR_SUM enabled and come back with SR_SUM still enabled. This patch addresses the problem allowing future work to enable full use of unsafe_get/put_XXX() macros without needing to take a CSR bit flip cost on every access. Make switch_to() save and restore SR_SUM.",
  "id": "DEBIAN-CVE-2025-38261",
  "modified": "2025-09-24T00:58:53.840709Z",
  "published": "2025-07-09T11:15:28Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2025-38261"
    }
  ],
  "schema_version": "1.7.3"
}