{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-50396.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:11",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "5.10.178-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "5.10.103-1",
        "5.10.103-1~bpo10+1",
        "5.10.106-1",
        "5.10.113-1",
        "5.10.120-1",
        "5.10.120-1~bpo10+1",
        "5.10.127-1",
        "5.10.127-2",
        "5.10.127-2~bpo10+1",
        "5.10.136-1",
        "5.10.140-1",
        "5.10.148-1",
        "5.10.149-1",
        "5.10.149-2",
        "5.10.158-1",
        "5.10.158-2",
        "5.10.162-1",
        "5.10.46-4",
        "5.10.46-5",
        "5.10.70-1",
        "5.10.70-1~bpo10+1",
        "5.10.84-1",
        "5.10.92-1",
        "5.10.92-1~bpo10+1",
        "5.10.92-2"
      ]
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-50396.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:12",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.7-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-50396.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.7-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2022-50396.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.7-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  net: sched: fix memory leak in tcindex_set_parms  Syzkaller reports a memory leak as follows: ==================================== BUG: memory leak unreferenced object 0xffff88810c287f00 (size 256):   comm \"syz-executor105\", pid 3600, jiffies 4294943292 (age 12.990s)   hex dump (first 32 bytes):     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................     00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................   backtrace:     [<ffffffff814cf9f0>] kmalloc_trace+0x20/0x90 mm/slab_common.c:1046     [<ffffffff839c9e07>] kmalloc include/linux/slab.h:576 [inline]     [<ffffffff839c9e07>] kmalloc_array include/linux/slab.h:627 [inline]     [<ffffffff839c9e07>] kcalloc include/linux/slab.h:659 [inline]     [<ffffffff839c9e07>] tcf_exts_init include/net/pkt_cls.h:250 [inline]     [<ffffffff839c9e07>] tcindex_set_parms+0xa7/0xbe0 net/sched/cls_tcindex.c:342     [<ffffffff839caa1f>] tcindex_change+0xdf/0x120 net/sched/cls_tcindex.c:553     [<ffffffff8394db62>] tc_new_tfilter+0x4f2/0x1100 net/sched/cls_api.c:2147     [<ffffffff8389e91c>] rtnetlink_rcv_msg+0x4dc/0x5d0 net/core/rtnetlink.c:6082     [<ffffffff839eba67>] netlink_rcv_skb+0x87/0x1d0 net/netlink/af_netlink.c:2540     [<ffffffff839eab87>] netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]     [<ffffffff839eab87>] netlink_unicast+0x397/0x4c0 net/netlink/af_netlink.c:1345     [<ffffffff839eb046>] netlink_sendmsg+0x396/0x710 net/netlink/af_netlink.c:1921     [<ffffffff8383e796>] sock_sendmsg_nosec net/socket.c:714 [inline]     [<ffffffff8383e796>] sock_sendmsg+0x56/0x80 net/socket.c:734     [<ffffffff8383eb08>] ____sys_sendmsg+0x178/0x410 net/socket.c:2482     [<ffffffff83843678>] ___sys_sendmsg+0xa8/0x110 net/socket.c:2536     [<ffffffff838439c5>] __sys_sendmmsg+0x105/0x330 net/socket.c:2622     [<ffffffff83843c14>] __do_sys_sendmmsg net/socket.c:2651 [inline]     [<ffffffff83843c14>] __se_sys_sendmmsg net/socket.c:2648 [inline]     [<ffffffff83843c14>] __x64_sys_sendmmsg+0x24/0x30 net/socket.c:2648     [<ffffffff84605fd5>] do_syscall_x64 arch/x86/entry/common.c:50 [inline]     [<ffffffff84605fd5>] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80     [<ffffffff84800087>] entry_SYSCALL_64_after_hwframe+0x63/0xcd ====================================  Kernel uses tcindex_change() to change an existing filter properties.  Yet the problem is that, during the process of changing, if `old_r` is retrieved from `p->perfect`, then kernel uses tcindex_alloc_perfect_hash() to newly allocate filter results, uses tcindex_filter_result_init() to clear the old filter result, without destroying its tcf_exts structure, which triggers the above memory leak.  To be more specific, there are only two source for the `old_r`, according to the tcindex_lookup(). `old_r` is retrieved from `p->perfect`, or `old_r` is retrieved from `p->h`.    * If `old_r` is retrieved from `p->perfect`, kernel uses tcindex_alloc_perfect_hash() to newly allocate the filter results. Then `r` is assigned with `cp->perfect + handle`, which is newly allocated. So condition `old_r && old_r != r` is true in this situation, and kernel uses tcindex_filter_result_init() to clear the old filter result, without destroying its tcf_exts structure    * If `old_r` is retrieved from `p->h`, then `p->perfect` is NULL according to the tcindex_lookup(). Considering that `cp->h` is directly copied from `p->h` and `p->perfect` is NULL, `r` is assigned with `tcindex_lookup(cp, handle)`, whose value should be the same as `old_r`, so condition `old_r && old_r != r` is false in this situation, kernel ignores using tcindex_filter_result_init() to clear the old filter result.  So only when `old_r` is retrieved from `p->perfect` does kernel use tcindex_filter_result_init() to clear the old filter result, which triggers the above memory leak.  Considering that there already exists a tc_filter_wq workqueue to destroy the old tcindex_d ---truncated---",
  "id": "DEBIAN-CVE-2022-50396",
  "modified": "2025-09-30T05:17:37.858389Z",
  "published": "2025-09-18T14:15:38Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2022-50396"
    }
  ],
  "schema_version": "1.7.3",
  "upstream": [
    "CVE-2022-50396"
  ]
}