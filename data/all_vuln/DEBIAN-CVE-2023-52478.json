{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-52478.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:11",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "5.10.205-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "5.10.103-1",
        "5.10.103-1~bpo10+1",
        "5.10.106-1",
        "5.10.113-1",
        "5.10.120-1",
        "5.10.120-1~bpo10+1",
        "5.10.127-1",
        "5.10.127-2",
        "5.10.127-2~bpo10+1",
        "5.10.136-1",
        "5.10.140-1",
        "5.10.148-1",
        "5.10.149-1",
        "5.10.149-2",
        "5.10.158-1",
        "5.10.158-2",
        "5.10.162-1",
        "5.10.178-1",
        "5.10.178-2",
        "5.10.178-3",
        "5.10.179-1",
        "5.10.179-2",
        "5.10.179-3",
        "5.10.179-4",
        "5.10.179-5",
        "5.10.191-1",
        "5.10.197-1",
        "5.10.46-4",
        "5.10.46-5",
        "5.10.70-1",
        "5.10.70-1~bpo10+1",
        "5.10.84-1",
        "5.10.92-1",
        "5.10.92-1~bpo10+1",
        "5.10.92-2"
      ]
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-52478.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:12",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.64-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "6.1.27-1",
        "6.1.37-1",
        "6.1.38-1",
        "6.1.38-2",
        "6.1.38-2~bpo11+1",
        "6.1.38-3",
        "6.1.38-4",
        "6.1.38-4~bpo11+1",
        "6.1.52-1",
        "6.1.55-1",
        "6.1.55-1~bpo11+1"
      ]
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-52478.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.5.8-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2023-52478.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.5.8-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  HID: logitech-hidpp: Fix kernel crash on receiver USB disconnect  hidpp_connect_event() has *four* time-of-check vs time-of-use (TOCTOU) races when it races with itself.  hidpp_connect_event() primarily runs from a workqueue but it also runs on probe() and if a \"device-connected\" packet is received by the hw when the thread running hidpp_connect_event() from probe() is waiting on the hw, then a second thread running hidpp_connect_event() will be started from the workqueue.  This opens the following races (note the below code is simplified):  1. Retrieving + printing the protocol (harmless race):  \tif (!hidpp->protocol_major) { \t\thidpp_root_get_protocol_version() \t\thidpp->protocol_major = response.rap.params[0]; \t}  We can actually see this race hit in the dmesg in the abrt output attached to rhbz#2227968:  [ 3064.624215] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected. [ 3064.658184] logitech-hidpp-device 0003:046D:4071.0049: HID++ 4.5 device connected.  Testing with extra logging added has shown that after this the 2 threads take turn grabbing the hw access mutex (send_mutex) so they ping-pong through all the other TOCTOU cases managing to hit all of them:  2. Updating the name to the HIDPP name (harmless race):  \tif (hidpp->name == hdev->name) { \t\t... \t\thidpp->name = new_name; \t}  3. Initializing the power_supply class for the battery (problematic!):  hidpp_initialize_battery() {         if (hidpp->battery.ps)                 return 0;  \tprobe_battery(); /* Blocks, threads take turns executing this */  \thidpp->battery.desc.properties = \t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);  \thidpp->battery.ps = \t\tdevm_power_supply_register(&hidpp->hid_dev->dev, \t\t\t\t\t   &hidpp->battery.desc, cfg); }  4. Creating delayed input_device (potentially problematic):  \tif (hidpp->delayed_input) \t\treturn;  \thidpp->delayed_input = hidpp_allocate_input(hdev);  The really big problem here is 3. Hitting the race leads to the following sequence:  \thidpp->battery.desc.properties = \t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);  \thidpp->battery.ps = \t\tdevm_power_supply_register(&hidpp->hid_dev->dev, \t\t\t\t\t   &hidpp->battery.desc, cfg);  \t...  \thidpp->battery.desc.properties = \t\tdevm_kmemdup(dev, hidpp_battery_props, cnt, GFP_KERNEL);  \thidpp->battery.ps = \t\tdevm_power_supply_register(&hidpp->hid_dev->dev, \t\t\t\t\t   &hidpp->battery.desc, cfg);  So now we have registered 2 power supplies for the same battery, which looks a bit weird from userspace's pov but this is not even the really big problem.  Notice how:  1. This is all devm-maganaged 2. The hidpp->battery.desc struct is shared between the 2 power supplies 3. hidpp->battery.desc.properties points to the result from the second    devm_kmemdup()  This causes a use after free scenario on USB disconnect of the receiver: 1. The last registered power supply class device gets unregistered 2. The memory from the last devm_kmemdup() call gets freed,    hidpp->battery.desc.properties now points to freed memory 3. The first registered power supply class device gets unregistered,    this involves sending a remove uevent to userspace which invokes    power_supply_uevent() to fill the uevent data 4. power_supply_uevent() uses hidpp->battery.desc.properties which    now points to freed memory leading to backtraces like this one:  Sep 22 20:01:35 eric kernel: BUG: unable to handle page fault for address: ffffb2140e017f08 ... Sep 22 20:01:35 eric kernel: Workqueue: usb_hub_wq hub_event Sep 22 20:01:35 eric kernel: RIP: 0010:power_supply_uevent+0xee/0x1d0 ... Sep 22 20:01:35 eric kernel:  ? asm_exc_page_fault+0x26/0x30 Sep 22 20:01:35 eric kernel:  ? power_supply_uevent+0xee/0x1d0 Sep 22 20:01:35 eric kernel:  ? power_supply_uevent+0x10d/0x1d0 Sep 22 20:01:35 eric kernel:  dev_uevent+0x10f/0x2d0 Sep 22 20:01:35 eric kernel:  kobject_uevent_env+0x291/0x680 Sep 22 20:01:35 eric kernel:   ---truncated---",
  "id": "DEBIAN-CVE-2023-52478",
  "modified": "2025-09-25T03:40:32.952615Z",
  "published": "2024-02-29T06:15:45Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2023-52478"
    }
  ],
  "schema_version": "1.7.3",
  "upstream": [
    "CVE-2023-52478"
  ]
}