{"schema_version":"1.7.3","id":"OESA-2024-2080","published":"2024-08-30T11:09:00Z","modified":"2025-09-03T06:17:49.747281Z","upstream":["CVE-2021-47292","CVE-2021-47504","CVE-2021-47556","CVE-2022-48634","CVE-2022-48639","CVE-2022-48642","CVE-2022-48643","CVE-2022-48644","CVE-2022-48647","CVE-2022-48648","CVE-2022-48656","CVE-2022-48663","CVE-2022-48671","CVE-2022-48672","CVE-2022-48675","CVE-2022-48686","CVE-2022-48687","CVE-2022-48691","CVE-2022-48873","CVE-2022-48896","CVE-2022-48898","CVE-2022-48899","CVE-2022-48920","CVE-2022-48935","CVE-2023-52893","CVE-2023-52898","CVE-2023-52901","CVE-2023-52903","CVE-2024-22386","CVE-2024-36946","CVE-2024-38613","CVE-2024-39490","CVE-2024-41002","CVE-2024-41068","CVE-2024-42120","CVE-2024-42122","CVE-2024-42265","CVE-2024-42271","CVE-2024-42280","CVE-2024-42281","CVE-2024-42284","CVE-2024-42285","CVE-2024-42297","CVE-2024-42305","CVE-2024-42308","CVE-2024-43819","CVE-2024-43828","CVE-2024-43831","CVE-2024-43853","CVE-2024-43860","CVE-2024-43861","CVE-2024-43866","CVE-2024-43879","CVE-2024-43882"],"summary":"kernel security update","details":"The Linux Kernel, the operating system core itself.\r\n\r\nSecurity Fix(es):\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nio_uring: fix memleak in io_init_wq_offload()\r\n\r\nI got memory leak report when doing fuzz test:\r\n\r\nBUG: memory leak\nunreferenced object 0xffff888107310a80 (size 96):\ncomm &quot;syz-executor.6&quot;, pid 4610, jiffies 4295140240 (age 20.135s)\nhex dump (first 32 bytes):\n01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................\n00 00 00 00 ad 4e ad de ff ff ff ff 00 00 00 00 .....N..........\nbacktrace:\n[&lt;000000001974933b&gt;] kmalloc include/linux/slab.h:591 [inline]\n[&lt;000000001974933b&gt;] kzalloc include/linux/slab.h:721 [inline]\n[&lt;000000001974933b&gt;] io_init_wq_offload fs/io_uring.c:7920 [inline]\n[&lt;000000001974933b&gt;] io_uring_alloc_task_context+0x466/0x640 fs/io_uring.c:7955\n[&lt;0000000039d0800d&gt;] __io_uring_add_tctx_node+0x256/0x360 fs/io_uring.c:9016\n[&lt;000000008482e78c&gt;] io_uring_add_tctx_node fs/io_uring.c:9052 [inline]\n[&lt;000000008482e78c&gt;] __do_sys_io_uring_enter fs/io_uring.c:9354 [inline]\n[&lt;000000008482e78c&gt;] __se_sys_io_uring_enter fs/io_uring.c:9301 [inline]\n[&lt;000000008482e78c&gt;] __x64_sys_io_uring_enter+0xabc/0xc20 fs/io_uring.c:9301\n[&lt;00000000b875f18f&gt;] do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n[&lt;00000000b875f18f&gt;] do_syscall_64+0x3b/0x90 arch/x86/entry/common.c:80\n[&lt;000000006b0a8484&gt;] entry_SYSCALL_64_after_hwframe+0x44/0xae\r\n\r\nCPU0                          CPU1\nio_uring_enter                io_uring_enter\nio_uring_add_tctx_node        io_uring_add_tctx_node\n__io_uring_add_tctx_node      __io_uring_add_tctx_node\nio_uring_alloc_task_context   io_uring_alloc_task_context\nio_init_wq_offload            io_init_wq_offload\nhash = kzalloc                hash = kzalloc\nctx-&gt;hash_map = hash          ctx-&gt;hash_map = hash &lt;- one of the hash is leaked\r\n\r\nWhen calling io_uring_enter() in parallel, the &apos;hash_map&apos; will be leaked,\nadd uring_lock to protect &apos;hash_map&apos;.(CVE-2021-47292)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nio_uring: ensure task_work gets run as part of cancelations\r\n\r\nIf we successfully cancel a work item but that work item needs to be\nprocessed through task_work, then we can be sleeping uninterruptibly\nin io_uring_cancel_generic() and never process it. Hence we don&apos;t\nmake forward progress and we end up with an uninterruptible sleep\nwarning.\r\n\r\nWhile in there, correct a comment that should be IFF, not IIF.(CVE-2021-47504)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nethtool: ioctl: fix potential NULL deref in ethtool_set_coalesce()\r\n\r\nethtool_set_coalesce() now uses both the .get_coalesce() and\n.set_coalesce() callbacks. But the check for their availability is\nbuggy, so changing the coalesce settings on a device where the driver\nprovides only _one_ of the callbacks results in a NULL pointer\ndereference instead of an -EOPNOTSUPP.\r\n\r\nFix the condition so that the availability of both callbacks is\nensured. This also matches the netlink code.\r\n\r\nNote that reproducing this requires some effort - it only affects the\nlegacy ioctl path, and needs a specific combination of driver options:\n- have .get_coalesce() and .coalesce_supported but no\n .set_coalesce(), or\n- have .set_coalesce() but no .get_coalesce(). Here eg. ethtool doesn&apos;t\n  cause the crash as it first attempts to call ethtool_get_coalesce()\n  and bails out on error.(CVE-2021-47556)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/gma500: Fix BUG: sleeping function called from invalid context errors\r\n\r\ngma_crtc_page_flip() was holding the event_lock spinlock while calling\ncrtc_funcs-&gt;mode_set_base() which takes ww_mutex.\r\n\r\nThe only reason to hold event_lock is to clear gma_crtc-&gt;page_flip_event\non mode_set_base() errors.\r\n\r\nInstead unlock it after setting gma_crtc-&gt;page_flip_event and on\nerrors re-take the lock and clear gma_crtc-&gt;page_flip_event it\nit is still set.\r\n\r\nThis fixes the following WARN/stacktrace:\r\n\r\n[  512.122953] BUG: sleeping function called from invalid context at kernel/locking/mutex.c:870\n[  512.123004] in_atomic(): 1, irqs_disabled(): 1, non_block: 0, pid: 1253, name: gnome-shell\n[  512.123031] preempt_count: 1, expected: 0\n[  512.123048] RCU nest depth: 0, expected: 0\n[  512.123066] INFO: lockdep is turned off.\n[  512.123080] irq event stamp: 0\n[  512.123094] hardirqs last  enabled at (0): [&lt;0000000000000000&gt;] 0x0\n[  512.123134] hardirqs last disabled at (0): [&lt;ffffffff8d0ec28c&gt;] copy_process+0x9fc/0x1de0\n[  512.123176] softirqs last  enabled at (0): [&lt;ffffffff8d0ec28c&gt;] copy_process+0x9fc/0x1de0\n[  512.123207] softirqs last disabled at (0): [&lt;0000000000000000&gt;] 0x0\n[  512.123233] Preemption disabled at:\n[  512.123241] [&lt;0000000000000000&gt;] 0x0\n[  512.123275] CPU: 3 PID: 1253 Comm: gnome-shell Tainted: G        W         5.19.0+ #1\n[  512.123304] Hardware name: Packard Bell dot s/SJE01_CT, BIOS V1.10 07/23/2013\n[  512.123323] Call Trace:\n[  512.123346]  &lt;TASK&gt;\n[  512.123370]  dump_stack_lvl+0x5b/0x77\n[  512.123412]  __might_resched.cold+0xff/0x13a\n[  512.123458]  ww_mutex_lock+0x1e/0xa0\n[  512.123495]  psb_gem_pin+0x2c/0x150 [gma500_gfx]\n[  512.123601]  gma_pipe_set_base+0x76/0x240 [gma500_gfx]\n[  512.123708]  gma_crtc_page_flip+0x95/0x130 [gma500_gfx]\n[  512.123808]  drm_mode_page_flip_ioctl+0x57d/0x5d0\n[  512.123897]  ? drm_mode_cursor2_ioctl+0x10/0x10\n[  512.123936]  drm_ioctl_kernel+0xa1/0x150\n[  512.123984]  drm_ioctl+0x21f/0x420\n[  512.124025]  ? drm_mode_cursor2_ioctl+0x10/0x10\n[  512.124070]  ? rcu_read_lock_bh_held+0xb/0x60\n[  512.124104]  ? lock_release+0x1ef/0x2d0\n[  512.124161]  __x64_sys_ioctl+0x8d/0xd0\n[  512.124203]  do_syscall_64+0x58/0x80\n[  512.124239]  ? do_syscall_64+0x67/0x80\n[  512.124267]  ? trace_hardirqs_on_prepare+0x55/0xe0\n[  512.124300]  ? do_syscall_64+0x67/0x80\n[  512.124340]  ? rcu_read_lock_sched_held+0x10/0x80\n[  512.124377]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n[  512.124411] RIP: 0033:0x7fcc4a70740f\n[  512.124442] Code: 00 48 89 44 24 18 31 c0 48 8d 44 24 60 c7 04 24 10 00 00 00 48 89 44 24 08 48 8d 44 24 20 48 89 44 24 10 b8 10 00 00 00 0f 05 &lt;89&gt; c2 3d 00 f0 ff ff 77 18 48 8b 44 24 18 64 48 2b 04 25 28 00 00\n[  512.124470] RSP: 002b:00007ffda73f5390 EFLAGS: 00000246 ORIG_RAX: 0000000000000010\n[  512.124503] RAX: ffffffffffffffda RBX: 000055cc9e474500 RCX: 00007fcc4a70740f\n[  512.124524] RDX: 00007ffda73f5420 RSI: 00000000c01864b0 RDI: 0000000000000009\n[  512.124544] RBP: 00007ffda73f5420 R08: 000055cc9c0b0cb0 R09: 0000000000000034\n[  512.124564] R10: 0000000000000000 R11: 0000000000000246 R12: 00000000c01864b0\n[  512.124584] R13: 0000000000000009 R14: 000055cc9df484d0 R15: 000055cc9af5d0c0\n[  512.124647]  &lt;/TASK&gt;(CVE-2022-48634)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnet: sched: fix possible refcount leak in tc_new_tfilter()\r\n\r\ntfilter_put need to be called to put the refount got by tp-&gt;ops-&gt;get to\navoid possible refcount leak when chain-&gt;tmplt_ops != NULL and\nchain-&gt;tmplt_ops != tp-&gt;ops.(CVE-2022-48639)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnetfilter: nf_tables: fix percpu memory leak at nf_tables_addchain()\r\n\r\nIt seems to me that percpu memory for chain stats started leaking since\ncommit 3bc158f8d0330f0a (&quot;netfilter: nf_tables: map basechain priority to\nhardware priority&quot;) when nft_chain_offload_priority() returned an error.(CVE-2022-48642)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnetfilter: nf_tables: fix nft_counters_enabled underflow at nf_tables_addchain()\r\n\r\nsyzbot is reporting underflow of nft_counters_enabled counter at\nnf_tables_addchain() [1], for commit 43eb8949cfdffa76 (&quot;netfilter:\nnf_tables: do not leave chain stats enabled on error&quot;) missed that\nnf_tables_chain_destroy() after nft_basechain_init() in the error path of\nnf_tables_addchain() decrements the counter because nft_basechain_init()\nmakes nft_is_base_chain() return true by setting NFT_CHAIN_BASE flag.\r\n\r\nIncrement the counter immediately after returning from\nnft_basechain_init().(CVE-2022-48643)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnet/sched: taprio: avoid disabling offload when it was never enabled\r\n\r\nIn an incredibly strange API design decision, qdisc-&gt;destroy() gets\ncalled even if qdisc-&gt;init() never succeeded, not exclusively since\ncommit 87b60cfacf9f (&quot;net_sched: fix error recovery at qdisc creation&quot;),\nbut apparently also earlier (in the case of qdisc_create_dflt()).\r\n\r\nThe taprio qdisc does not fully acknowledge this when it attempts full\noffload, because it starts off with q-&gt;flags = TAPRIO_FLAGS_INVALID in\ntaprio_init(), then it replaces q-&gt;flags with TCA_TAPRIO_ATTR_FLAGS\nparsed from netlink (in taprio_change(), tail called from taprio_init()).\r\n\r\nBut in taprio_destroy(), we call taprio_disable_offload(), and this\ndetermines what to do based on FULL_OFFLOAD_IS_ENABLED(q-&gt;flags).\r\n\r\nBut looking at the implementation of FULL_OFFLOAD_IS_ENABLED()\n(a bitwise check of bit 1 in q-&gt;flags), it is invalid to call this macro\non q-&gt;flags when it contains TAPRIO_FLAGS_INVALID, because that is set\nto U32_MAX, and therefore FULL_OFFLOAD_IS_ENABLED() will return true on\nan invalid set of flags.\r\n\r\nAs a result, it is possible to crash the kernel if user space forces an\nerror between setting q-&gt;flags = TAPRIO_FLAGS_INVALID, and the calling\nof taprio_enable_offload(). This is because drivers do not expect the\noffload to be disabled when it was never enabled.\r\n\r\nThe error that we force here is to attach taprio as a non-root qdisc,\nbut instead as child of an mqprio root qdisc:\r\n\r\n$ tc qdisc add dev swp0 root handle 1: \\\n\tmqprio num_tc 8 map 0 1 2 3 4 5 6 7 \\\n\tqueues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 hw 0\n$ tc qdisc replace dev swp0 parent 1:1 \\\n\ttaprio num_tc 8 map 0 1 2 3 4 5 6 7 \\\n\tqueues 1@0 1@1 1@2 1@3 1@4 1@5 1@6 1@7 base-time 0 \\\n\tsched-entry S 0x7f 990000 sched-entry S 0x80 100000 \\\n\tflags 0x0 clockid CLOCK_TAI\nUnable to handle kernel paging request at virtual address fffffffffffffff8\n[fffffffffffffff8] pgd=0000000000000000, p4d=0000000000000000\nInternal error: Oops: 96000004 [#1] PREEMPT SMP\nCall trace:\n taprio_dump+0x27c/0x310\n vsc9959_port_setup_tc+0x1f4/0x460\n felix_port_setup_tc+0x24/0x3c\n dsa_slave_setup_tc+0x54/0x27c\n taprio_disable_offload.isra.0+0x58/0xe0\n taprio_destroy+0x80/0x104\n qdisc_create+0x240/0x470\n tc_modify_qdisc+0x1fc/0x6b0\n rtnetlink_rcv_msg+0x12c/0x390\n netlink_rcv_skb+0x5c/0x130\n rtnetlink_rcv+0x1c/0x2c\r\n\r\nFix this by keeping track of the operations we made, and undo the\noffload only if we actually did it.\r\n\r\nI&apos;ve added &quot;bool offloaded&quot; inside a 4 byte hole between &quot;int clockid&quot;\nand &quot;atomic64_t picos_per_byte&quot;. Now the first cache line looks like\nbelow:\r\n\r\n$ pahole -C taprio_sched net/sched/sch_taprio.o\nstruct taprio_sched {\n        struct Qdisc * *           qdiscs;               /*     0     8 */\n        struct Qdisc *             root;                 /*     8     8 */\n        u32                        flags;                /*    16     4 */\n        enum tk_offsets            tk_offset;            /*    20     4 */\n        int                        clockid;              /*    24     4 */\n        bool                       offloaded;            /*    28     1 */\r\n\r\n        /* XXX 3 bytes hole, try to pack */\r\n\r\n        atomic64_t                 picos_per_byte;       /*    32     0 */\r\n\r\n        /* XXX 8 bytes hole, try to pack */\r\n\r\n        spinlock_t                 current_entry_lock;   /*    40     0 */\r\n\r\n        /* XXX 8 bytes hole, try to pack */\r\n\r\n        struct sched_entry *       current_entry;        /*    48     8 */\n        struct sched_gate_list *   oper_sched;           /*    56     8 */\n        /* --- cacheline 1 boundary (64 bytes) --- */(CVE-2022-48644)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nsfc: fix TX channel offset when using legacy interrupts\r\n\r\nIn legacy interrupt mode the tx_channel_offset was hardcoded to 1, but\nthat&apos;s not correct if efx_sepparate_tx_channels is false. In that case,\nthe offset is 0 because the tx queues are in the single existing channel\nat index 0, together with the rx queue.\r\n\r\nWithout this fix, as soon as you try to send any traffic, it tries to\nget the tx queues from an uninitialized channel getting these errors:\n  WARNING: CPU: 1 PID: 0 at drivers/net/ethernet/sfc/tx.c:540 efx_hard_start_xmit+0x12e/0x170 [sfc]\n  [...]\n  RIP: 0010:efx_hard_start_xmit+0x12e/0x170 [sfc]\n  [...]\n  Call Trace:\n   &lt;IRQ&gt;\n   dev_hard_start_xmit+0xd7/0x230\n   sch_direct_xmit+0x9f/0x360\n   __dev_queue_xmit+0x890/0xa40\n  [...]\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000020\n  [...]\n  RIP: 0010:efx_hard_start_xmit+0x153/0x170 [sfc]\n  [...]\n  Call Trace:\n   &lt;IRQ&gt;\n   dev_hard_start_xmit+0xd7/0x230\n   sch_direct_xmit+0x9f/0x360\n   __dev_queue_xmit+0x890/0xa40\n  [...](CVE-2022-48647)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nsfc: fix null pointer dereference in efx_hard_start_xmit\r\n\r\nTrying to get the channel from the tx_queue variable here is wrong\nbecause we can only be here if tx_queue is NULL, so we shouldn&apos;t\ndereference it. As the above comment in the code says, this is very\nunlikely to happen, but it&apos;s wrong anyway so let&apos;s fix it.\r\n\r\nI hit this issue because of a different bug that caused tx_queue to be\nNULL. If that happens, this is the error message that we get here:\n  BUG: unable to handle kernel NULL pointer dereference at 0000000000000020\n  [...]\n  RIP: 0010:efx_hard_start_xmit+0x153/0x170 [sfc](CVE-2022-48648)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndmaengine: ti: k3-udma-private: Fix refcount leak bug in of_xudma_dev_get()\r\n\r\nWe should call of_node_put() for the reference returned by\nof_parse_phandle() in fail path or when it is not used anymore.\nHere we only need to move the of_node_put() before the check.(CVE-2022-48656)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ngpio: mockup: fix NULL pointer dereference when removing debugfs\r\n\r\nWe now remove the device&apos;s debugfs entries when unbinding the driver.\nThis now causes a NULL-pointer dereference on module exit because the\nplatform devices are unregistered *after* the global debugfs directory\nhas been recursively removed. Fix it by unregistering the devices first.(CVE-2022-48663)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ncgroup: Add missing cpus_read_lock() to cgroup_attach_task_all()\r\n\r\nsyzbot is hitting percpu_rwsem_assert_held(&amp;cpu_hotplug_lock) warning at\ncpuset_attach() [1], for commit 4f7e7236435ca0ab (&quot;cgroup: Fix\nthreadgroup_rwsem &lt;-&gt; cpus_read_lock() deadlock&quot;) missed that\ncpuset_attach() is also called from cgroup_attach_task_all().\nAdd cpus_read_lock() like what cgroup_procs_write_start() does.(CVE-2022-48671)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nof: fdt: fix off-by-one error in unflatten_dt_nodes()\r\n\r\nCommit 78c44d910d3e (&quot;drivers/of: Fix depth when unflattening devicetree&quot;)\nforgot to fix up the depth check in the loop body in unflatten_dt_nodes()\nwhich makes it possible to overflow the nps[] buffer...\r\n\r\nFound by Linux Verification Center (linuxtesting.org) with the SVACE static\nanalysis tool.(CVE-2022-48672)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nIB/core: Fix a nested dead lock as part of ODP flow\r\n\r\nFix a nested dead lock as part of ODP flow by using mmput_async().\r\n\r\nFrom the below call trace [1] can see that calling mmput() once we have\nthe umem_odp-&gt;umem_mutex locked as required by\nib_umem_odp_map_dma_and_lock() might trigger in the same task the\nexit_mmap()-&gt;__mmu_notifier_release()-&gt;mlx5_ib_invalidate_range() which\nmay dead lock when trying to lock the same mutex.\r\n\r\nMoving to use mmput_async() will solve the problem as the above\nexit_mmap() flow will be called in other task and will be executed once\nthe lock will be available.\r\n\r\n[1]\n[64843.077665] task:kworker/u133:2  state:D stack:    0 pid:80906 ppid:\n2 flags:0x00004000\n[64843.077672] Workqueue: mlx5_ib_page_fault mlx5_ib_eqe_pf_action [mlx5_ib]\n[64843.077719] Call Trace:\n[64843.077722]  &lt;TASK&gt;\n[64843.077724]  __schedule+0x23d/0x590\n[64843.077729]  schedule+0x4e/0xb0\n[64843.077735]  schedule_preempt_disabled+0xe/0x10\n[64843.077740]  __mutex_lock.constprop.0+0x263/0x490\n[64843.077747]  __mutex_lock_slowpath+0x13/0x20\n[64843.077752]  mutex_lock+0x34/0x40\n[64843.077758]  mlx5_ib_invalidate_range+0x48/0x270 [mlx5_ib]\n[64843.077808]  __mmu_notifier_release+0x1a4/0x200\n[64843.077816]  exit_mmap+0x1bc/0x200\n[64843.077822]  ? walk_page_range+0x9c/0x120\n[64843.077828]  ? __cond_resched+0x1a/0x50\n[64843.077833]  ? mutex_lock+0x13/0x40\n[64843.077839]  ? uprobe_clear_state+0xac/0x120\n[64843.077860]  mmput+0x5f/0x140\n[64843.077867]  ib_umem_odp_map_dma_and_lock+0x21b/0x580 [ib_core]\n[64843.077931]  pagefault_real_mr+0x9a/0x140 [mlx5_ib]\n[64843.077962]  pagefault_mr+0xb4/0x550 [mlx5_ib]\n[64843.077992]  pagefault_single_data_segment.constprop.0+0x2ac/0x560\n[mlx5_ib]\n[64843.078022]  mlx5_ib_eqe_pf_action+0x528/0x780 [mlx5_ib]\n[64843.078051]  process_one_work+0x22b/0x3d0\n[64843.078059]  worker_thread+0x53/0x410\n[64843.078065]  ? process_one_work+0x3d0/0x3d0\n[64843.078073]  kthread+0x12a/0x150\n[64843.078079]  ? set_kthread_struct+0x50/0x50\n[64843.078085]  ret_from_fork+0x22/0x30\n[64843.078093]  &lt;/TASK&gt;(CVE-2022-48675)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnvme-tcp: fix UAF when detecting digest errors\r\n\r\nWe should also bail from the io_work loop when we set rd_enabled to true,\nso we don&apos;t attempt to read data from the socket when the TCP stream is\nalready out-of-sync or corrupted.(CVE-2022-48686)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nipv6: sr: fix out-of-bounds read when setting HMAC data.\r\n\r\nThe SRv6 layer allows defining HMAC data that can later be used to sign IPv6\nSegment Routing Headers. This configuration is realised via netlink through\nfour attributes: SEG6_ATTR_HMACKEYID, SEG6_ATTR_SECRET, SEG6_ATTR_SECRETLEN and\nSEG6_ATTR_ALGID. Because the SECRETLEN attribute is decoupled from the actual\nlength of the SECRET attribute, it is possible to provide invalid combinations\n(e.g., secret = &quot;&quot;, secretlen = 64). This case is not checked in the code and\nwith an appropriately crafted netlink message, an out-of-bounds read of up\nto 64 bytes (max secret length) can occur past the skb end pointer and into\nskb_shared_info:\r\n\r\nBreakpoint 1, seg6_genl_sethmac (skb=&lt;optimized out&gt;, info=&lt;optimized out&gt;) at net/ipv6/seg6.c:208\n208\t\tmemcpy(hinfo-&gt;secret, secret, slen);\n(gdb) bt\n #0  seg6_genl_sethmac (skb=&lt;optimized out&gt;, info=&lt;optimized out&gt;) at net/ipv6/seg6.c:208\n #1  0xffffffff81e012e9 in genl_family_rcv_msg_doit (skb=skb@entry=0xffff88800b1f9f00, nlh=nlh@entry=0xffff88800b1b7600,\n    extack=extack@entry=0xffffc90000ba7af0, ops=ops@entry=0xffffc90000ba7a80, hdrlen=4, net=0xffffffff84237580 &lt;init_net&gt;, family=&lt;optimized out&gt;,\n    family=&lt;optimized out&gt;) at net/netlink/genetlink.c:731\n #2  0xffffffff81e01435 in genl_family_rcv_msg (extack=0xffffc90000ba7af0, nlh=0xffff88800b1b7600, skb=0xffff88800b1f9f00,\n    family=0xffffffff82fef6c0 &lt;seg6_genl_family&gt;) at net/netlink/genetlink.c:775\n #3  genl_rcv_msg (skb=0xffff88800b1f9f00, nlh=0xffff88800b1b7600, extack=0xffffc90000ba7af0) at net/netlink/genetlink.c:792\n #4  0xffffffff81dfffc3 in netlink_rcv_skb (skb=skb@entry=0xffff88800b1f9f00, cb=cb@entry=0xffffffff81e01350 &lt;genl_rcv_msg&gt;)\n    at net/netlink/af_netlink.c:2501\n #5  0xffffffff81e00919 in genl_rcv (skb=0xffff88800b1f9f00) at net/netlink/genetlink.c:803\n #6  0xffffffff81dff6ae in netlink_unicast_kernel (ssk=0xffff888010eec800, skb=0xffff88800b1f9f00, sk=0xffff888004aed000)\n    at net/netlink/af_netlink.c:1319\n #7  netlink_unicast (ssk=ssk@entry=0xffff888010eec800, skb=skb@entry=0xffff88800b1f9f00, portid=portid@entry=0, nonblock=&lt;optimized out&gt;)\n    at net/netlink/af_netlink.c:1345\n #8  0xffffffff81dff9a4 in netlink_sendmsg (sock=&lt;optimized out&gt;, msg=0xffffc90000ba7e48, len=&lt;optimized out&gt;) at net/netlink/af_netlink.c:1921\n...\n(gdb) p/x ((struct sk_buff *)0xffff88800b1f9f00)-&gt;head + ((struct sk_buff *)0xffff88800b1f9f00)-&gt;end\n$1 = 0xffff88800b1b76c0\n(gdb) p/x secret\n$2 = 0xffff88800b1b76c0\n(gdb) p slen\n$3 = 64 &apos;@&apos;\r\n\r\nThe OOB data can then be read back from userspace by dumping HMAC state. This\ncommit fixes this by ensuring SECRETLEN cannot exceed the actual length of\nSECRET.(CVE-2022-48687)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnetfilter: nf_tables: clean up hook list when offload flags check fails\r\n\r\nsplice back the hook list so nft_chain_release_hook() has a chance to\nrelease the hooks.\r\n\r\nBUG: memory leak\nunreferenced object 0xffff88810180b100 (size 96):\n  comm &quot;syz-executor133&quot;, pid 3619, jiffies 4294945714 (age 12.690s)\n  hex dump (first 32 bytes):\n    28 64 23 02 81 88 ff ff 28 64 23 02 81 88 ff ff  (d#.....(d#.....\n    90 a8 aa 83 ff ff ff ff 00 00 b5 0f 81 88 ff ff  ................\n  backtrace:\n    [&lt;ffffffff83a8c59b&gt;] kmalloc include/linux/slab.h:600 [inline]\n    [&lt;ffffffff83a8c59b&gt;] nft_netdev_hook_alloc+0x3b/0xc0 net/netfilter/nf_tables_api.c:1901\n    [&lt;ffffffff83a9239a&gt;] nft_chain_parse_netdev net/netfilter/nf_tables_api.c:1998 [inline]\n    [&lt;ffffffff83a9239a&gt;] nft_chain_parse_hook+0x33a/0x530 net/netfilter/nf_tables_api.c:2073\n    [&lt;ffffffff83a9b14b&gt;] nf_tables_addchain.constprop.0+0x10b/0x950 net/netfilter/nf_tables_api.c:2218\n    [&lt;ffffffff83a9c41b&gt;] nf_tables_newchain+0xa8b/0xc60 net/netfilter/nf_tables_api.c:2593\n    [&lt;ffffffff83a3d6a6&gt;] nfnetlink_rcv_batch+0xa46/0xd20 net/netfilter/nfnetlink.c:517\n    [&lt;ffffffff83a3db79&gt;] nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:638 [inline]\n    [&lt;ffffffff83a3db79&gt;] nfnetlink_rcv+0x1f9/0x220 net/netfilter/nfnetlink.c:656\n    [&lt;ffffffff83a13b17&gt;] netlink_unicast_kernel net/netlink/af_netlink.c:1319 [inline]\n    [&lt;ffffffff83a13b17&gt;] netlink_unicast+0x397/0x4c0 net/netlink/af_netlink.c:1345\n    [&lt;ffffffff83a13fd6&gt;] netlink_sendmsg+0x396/0x710 net/netlink/af_netlink.c:1921\n    [&lt;ffffffff83865ab6&gt;] sock_sendmsg_nosec net/socket.c:714 [inline]\n    [&lt;ffffffff83865ab6&gt;] sock_sendmsg+0x56/0x80 net/socket.c:734\n    [&lt;ffffffff8386601c&gt;] ____sys_sendmsg+0x36c/0x390 net/socket.c:2482\n    [&lt;ffffffff8386a918&gt;] ___sys_sendmsg+0xa8/0x110 net/socket.c:2536\n    [&lt;ffffffff8386aaa8&gt;] __sys_sendmsg+0x88/0x100 net/socket.c:2565\n    [&lt;ffffffff845e5955&gt;] do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n    [&lt;ffffffff845e5955&gt;] do_syscall_64+0x35/0xb0 arch/x86/entry/common.c:80\n    [&lt;ffffffff84800087&gt;] entry_SYSCALL_64_after_hwframe+0x63/0xcd(CVE-2022-48691)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nmisc: fastrpc: Don&apos;t remove map on creater_process and device_release\r\n\r\nDo not remove the map from the list on error path in\nfastrpc_init_create_process, instead call fastrpc_map_put, to avoid\nuse-after-free. Do not remove it on fastrpc_device_release either,\ncall fastrpc_map_put instead.\r\n\r\nThe fastrpc_free_map is the only proper place to remove the map.\nThis is called only after the reference count is 0.(CVE-2022-48873)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nixgbe: fix pci device refcount leak\r\n\r\nAs the comment of pci_get_domain_bus_and_slot() says, it\nreturns a PCI device with refcount incremented, when finish\nusing it, the caller must decrement the reference count by\ncalling pci_dev_put().\r\n\r\nIn ixgbe_get_first_secondary_devfn() and ixgbe_x550em_a_has_mii(),\npci_dev_put() is called to avoid leak.(CVE-2022-48896)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/msm/dp: do not complete dp_aux_cmd_fifo_tx() if irq is not for aux transfer\r\n\r\nThere are 3 possible interrupt sources are handled by DP controller,\nHPDstatus, Controller state changes and Aux read/write transaction.\nAt every irq, DP controller have to check isr status of every interrupt\nsources and service the interrupt if its isr status bits shows interrupts\nare pending. There is potential race condition may happen at current aux\nisr handler implementation since it is always complete dp_aux_cmd_fifo_tx()\neven irq is not for aux read or write transaction. This may cause aux read\ntransaction return premature if host aux data read is in the middle of\nwaiting for sink to complete transferring data to host while irq happen.\nThis will cause host&apos;s receiving buffer contains unexpected data. This\npatch fixes this problem by checking aux isr and return immediately at\naux isr handler if there are no any isr status bits set.\r\n\r\nCurrent there is a bug report regrading eDP edid corruption happen during\nsystem booting up. After lengthy debugging to found that VIDEO_READY\ninterrupt was continuously firing during system booting up which cause\ndp_aux_isr() to complete dp_aux_cmd_fifo_tx() prematurely to retrieve data\nfrom aux hardware buffer which is not yet contains complete data transfer\nfrom sink. This cause edid corruption.\r\n\r\nFollows are the signature at kernel logs when problem happen,\nEDID has corrupt header\npanel-simple-dp-aux aux-aea0000.edp: Couldn&apos;t identify panel via EDID\r\n\r\nChanges in v2:\n-- do complete if (ret == IRQ_HANDLED) ay dp-aux_isr()\n-- add more commit text\r\n\r\nChanges in v3:\n-- add Stephen suggested\n-- dp_aux_isr() return IRQ_XXX back to caller\n-- dp_ctrl_isr() return IRQ_XXX back to caller\r\n\r\nChanges in v4:\n-- split into two patches\r\n\r\nChanges in v5:\n-- delete empty line between tags\r\n\r\nChanges in v6:\n-- remove extra &quot;that&quot; and fixed line more than 75 char at commit text\r\n\r\nPatchwork: https://patchwork.freedesktop.org/patch/516121/(CVE-2022-48898)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/virtio: Fix GEM handle creation UAF\r\n\r\nUserspace can guess the handle value and try to race GEM object creation\nwith handle close, resulting in a use-after-free if we dereference the\nobject after dropping the handle&apos;s reference.  For that reason, dropping\nthe handle&apos;s reference must be done *after* we are done dereferencing\nthe object.(CVE-2022-48899)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nbtrfs: get rid of warning on transaction commit when using flushoncommit\r\n\r\nWhen using the flushoncommit mount option, during almost every transaction\ncommit we trigger a warning from __writeback_inodes_sb_nr():\r\n\r\n  $ cat fs/fs-writeback.c:\n  (...)\n  static void __writeback_inodes_sb_nr(struct super_block *sb, ...\n  {\n        (...)\n        WARN_ON(!rwsem_is_locked(&amp;sb-&gt;s_umount));\n        (...)\n  }\n  (...)\r\n\r\nThe trace produced in dmesg looks like the following:\r\n\r\n  [947.473890] WARNING: CPU: 5 PID: 930 at fs/fs-writeback.c:2610 __writeback_inodes_sb_nr+0x7e/0xb3\n  [947.481623] Modules linked in: nfsd nls_cp437 cifs asn1_decoder cifs_arc4 fscache cifs_md4 ipmi_ssif\n  [947.489571] CPU: 5 PID: 930 Comm: btrfs-transacti Not tainted 95.16.3-srb-asrock-00001-g36437ad63879 #186\n  [947.497969] RIP: 0010:__writeback_inodes_sb_nr+0x7e/0xb3\n  [947.502097] Code: 24 10 4c 89 44 24 18 c6 (...)\n  [947.519760] RSP: 0018:ffffc90000777e10 EFLAGS: 00010246\n  [947.523818] RAX: 0000000000000000 RBX: 0000000000963300 RCX: 0000000000000000\n  [947.529765] RDX: 0000000000000000 RSI: 000000000000fa51 RDI: ffffc90000777e50\n  [947.535740] RBP: ffff888101628a90 R08: ffff888100955800 R09: ffff888100956000\n  [947.541701] R10: 0000000000000002 R11: 0000000000000001 R12: ffff888100963488\n  [947.547645] R13: ffff888100963000 R14: ffff888112fb7200 R15: ffff888100963460\n  [947.553621] FS:  0000000000000000(0000) GS:ffff88841fd40000(0000) knlGS:0000000000000000\n  [947.560537] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  [947.565122] CR2: 0000000008be50c4 CR3: 000000000220c000 CR4: 00000000001006e0\n  [947.571072] Call Trace:\n  [947.572354]  &lt;TASK&gt;\n  [947.573266]  btrfs_commit_transaction+0x1f1/0x998\n  [947.576785]  ? start_transaction+0x3ab/0x44e\n  [947.579867]  ? schedule_timeout+0x8a/0xdd\n  [947.582716]  transaction_kthread+0xe9/0x156\n  [947.585721]  ? btrfs_cleanup_transaction.isra.0+0x407/0x407\n  [947.590104]  kthread+0x131/0x139\n  [947.592168]  ? set_kthread_struct+0x32/0x32\n  [947.595174]  ret_from_fork+0x22/0x30\n  [947.597561]  &lt;/TASK&gt;\n  [947.598553] ---[ end trace 644721052755541c ]---\r\n\r\nThis is because we started using writeback_inodes_sb() to flush delalloc\nwhen committing a transaction (when using -o flushoncommit), in order to\navoid deadlocks with filesystem freeze operations. This change was made\nby commit ce8ea7cc6eb313 (&quot;btrfs: don&apos;t call btrfs_start_delalloc_roots\nin flushoncommit&quot;). After that change we started producing that warning,\nand every now and then a user reports this since the warning happens too\noften, it spams dmesg/syslog, and a user is unsure if this reflects any\nproblem that might compromise the filesystem&apos;s reliability.\r\n\r\nWe can not just lock the sb-&gt;s_umount semaphore before calling\nwriteback_inodes_sb(), because that would at least deadlock with\nfilesystem freezing, since at fs/super.c:freeze_super() sync_filesystem()\nis called while we are holding that semaphore in write mode, and that can\ntrigger a transaction commit, resulting in a deadlock. It would also\ntrigger the same type of deadlock in the unmount path. Possibly, it could\nalso introduce some other locking dependencies that lockdep would report.\r\n\r\nTo fix this call try_to_writeback_inodes_sb() instead of\nwriteback_inodes_sb(), because that will try to read lock sb-&gt;s_umount\nand then will only call writeback_inodes_sb() if it was able to lock it.\nThis is fine because the cases where it can&apos;t read lock sb-&gt;s_umount\nare during a filesystem unmount or during a filesystem freeze - in those\ncases sb-&gt;s_umount is write locked and sync_filesystem() is called, which\ncalls writeback_inodes_sb(). In other words, in all cases where we can&apos;t\ntake a read lock on sb-&gt;s_umount, writeback is already being triggered\nelsewhere.\r\n\r\nAn alternative would be to call btrfs_start_delalloc_roots() with a\nnumber of pages different from LONG_MAX, for example matching the number\nof delalloc bytes we currently have, in \n---truncated---(CVE-2022-48920)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnetfilter: nf_tables: unregister flowtable hooks on netns exit\r\n\r\nUnregister flowtable hooks before they are releases via\nnf_tables_flowtable_destroy() otherwise hook core reports UAF.\r\n\r\nBUG: KASAN: use-after-free in nf_hook_entries_grow+0x5a7/0x700 net/netfilter/core.c:142 net/netfilter/core.c:142\nRead of size 4 at addr ffff8880736f7438 by task syz-executor579/3666\r\n\r\nCPU: 0 PID: 3666 Comm: syz-executor579 Not tainted 5.16.0-rc5-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nCall Trace:\n &lt;TASK&gt;\n __dump_stack lib/dump_stack.c:88 [inline]\n __dump_stack lib/dump_stack.c:88 [inline] lib/dump_stack.c:106\n dump_stack_lvl+0x1dc/0x2d8 lib/dump_stack.c:106 lib/dump_stack.c:106\n print_address_description+0x65/0x380 mm/kasan/report.c:247 mm/kasan/report.c:247\n __kasan_report mm/kasan/report.c:433 [inline]\n __kasan_report mm/kasan/report.c:433 [inline] mm/kasan/report.c:450\n kasan_report+0x19a/0x1f0 mm/kasan/report.c:450 mm/kasan/report.c:450\n nf_hook_entries_grow+0x5a7/0x700 net/netfilter/core.c:142 net/netfilter/core.c:142\n __nf_register_net_hook+0x27e/0x8d0 net/netfilter/core.c:429 net/netfilter/core.c:429\n nf_register_net_hook+0xaa/0x180 net/netfilter/core.c:571 net/netfilter/core.c:571\n nft_register_flowtable_net_hooks+0x3c5/0x730 net/netfilter/nf_tables_api.c:7232 net/netfilter/nf_tables_api.c:7232\n nf_tables_newflowtable+0x2022/0x2cf0 net/netfilter/nf_tables_api.c:7430 net/netfilter/nf_tables_api.c:7430\n nfnetlink_rcv_batch net/netfilter/nfnetlink.c:513 [inline]\n nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:634 [inline]\n nfnetlink_rcv_batch net/netfilter/nfnetlink.c:513 [inline] net/netfilter/nfnetlink.c:652\n nfnetlink_rcv_skb_batch net/netfilter/nfnetlink.c:634 [inline] net/netfilter/nfnetlink.c:652\n nfnetlink_rcv+0x10e6/0x2550 net/netfilter/nfnetlink.c:652 net/netfilter/nfnetlink.c:652\r\n\r\n__nft_release_hook() calls nft_unregister_flowtable_net_hooks() which\nonly unregisters the hooks, then after RCU grace period, it is\nguaranteed that no packets add new entries to the flowtable (no flow\noffload rules and flowtable hooks are reachable from packet path), so it\nis safe to call nf_flow_table_free() which cleans up the remaining\nentries from the flowtable (both software and hardware) and it unbinds\nthe flow_block.(CVE-2022-48935)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ngsmi: fix null-deref in gsmi_get_variable\r\n\r\nWe can get EFI variables without fetching the attribute, so we must\nallow for that in gsmi.\r\n\r\ncommit 859748255b43 (&quot;efi: pstore: Omit efivars caching EFI varstore\naccess layer&quot;) added a new get_variable call with attr=NULL, which\ntriggers panic in gsmi.(CVE-2023-52893)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nxhci: Fix null pointer dereference when host dies\r\n\r\nMake sure xhci_free_dev() and xhci_kill_endpoint_urbs() do not race\nand cause null pointer dereference when host suddenly dies.\r\n\r\nUsb core may call xhci_free_dev() which frees the xhci-&gt;devs[slot_id]\nvirt device at the same time that xhci_kill_endpoint_urbs() tries to\nloop through all the device&apos;s endpoints, checking if there are any\ncancelled urbs left to give back.\r\n\r\nhold the xhci spinlock while freeing the virt device(CVE-2023-52898)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nusb: xhci: Check endpoint is valid before dereferencing it\r\n\r\nWhen the host controller is not responding, all URBs queued to all\nendpoints need to be killed. This can cause a kernel panic if we\ndereference an invalid endpoint.\r\n\r\nFix this by using xhci_get_virt_ep() helper to find the endpoint and\nchecking if the endpoint is valid before dereferencing it.\r\n\r\n[233311.853271] xhci-hcd xhci-hcd.1.auto: xHCI host controller not responding, assume dead\n[233311.853393] Unable to handle kernel NULL pointer dereference at virtual address 00000000000000e8\r\n\r\n[233311.853964] pc : xhci_hc_died+0x10c/0x270\n[233311.853971] lr : xhci_hc_died+0x1ac/0x270\r\n\r\n[233311.854077] Call trace:\n[233311.854085]  xhci_hc_died+0x10c/0x270\n[233311.854093]  xhci_stop_endpoint_command_watchdog+0x100/0x1a4\n[233311.854105]  call_timer_fn+0x50/0x2d4\n[233311.854112]  expire_timers+0xac/0x2e4\n[233311.854118]  run_timer_softirq+0x300/0xabc\n[233311.854127]  __do_softirq+0x148/0x528\n[233311.854135]  irq_exit+0x194/0x1a8\n[233311.854143]  __handle_domain_irq+0x164/0x1d0\n[233311.854149]  gic_handle_irq.22273+0x10c/0x188\n[233311.854156]  el1_irq+0xfc/0x1a8\n[233311.854175]  lpm_cpuidle_enter+0x25c/0x418 [msm_pm]\n[233311.854185]  cpuidle_enter_state+0x1f0/0x764\n[233311.854194]  do_idle+0x594/0x6ac\n[233311.854201]  cpu_startup_entry+0x7c/0x80\n[233311.854209]  secondary_start_kernel+0x170/0x198(CVE-2023-52901)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nio_uring: lock overflowing for IOPOLL\r\n\r\nsyzbot reports an issue with overflow filling for IOPOLL:\r\n\r\nWARNING: CPU: 0 PID: 28 at io_uring/io_uring.c:734 io_cqring_event_overflow+0x1c0/0x230 io_uring/io_uring.c:734\nCPU: 0 PID: 28 Comm: kworker/u4:1 Not tainted 6.2.0-rc3-syzkaller-16369-g358a161a6a9e #0\nWorkqueue: events_unbound io_ring_exit_work\nCall trace:\n io_cqring_event_overflow+0x1c0/0x230 io_uring/io_uring.c:734\n io_req_cqe_overflow+0x5c/0x70 io_uring/io_uring.c:773\n io_fill_cqe_req io_uring/io_uring.h:168 [inline]\n io_do_iopoll+0x474/0x62c io_uring/rw.c:1065\n io_iopoll_try_reap_events+0x6c/0x108 io_uring/io_uring.c:1513\n io_uring_try_cancel_requests+0x13c/0x258 io_uring/io_uring.c:3056\n io_ring_exit_work+0xec/0x390 io_uring/io_uring.c:2869\n process_one_work+0x2d8/0x504 kernel/workqueue.c:2289\n worker_thread+0x340/0x610 kernel/workqueue.c:2436\n kthread+0x12c/0x158 kernel/kthread.c:376\n ret_from_fork+0x10/0x20 arch/arm64/kernel/entry.S:863\r\n\r\nThere is no real problem for normal IOPOLL as flush is also called with\nuring_lock taken, but it&apos;s getting more complicated for IOPOLL|SQPOLL,\nfor which __io_cqring_overflow_flush() happens from the CQ waiting path.(CVE-2023-52903)\r\n\r\nA race condition was found in the Linux kernel&apos;s drm/exynos device driver in exynos_drm_crtc_atomic_disable() function. This can result in a null pointer dereference issue, possibly leading to a kernel panic or denial of service issue.\r\n\r\n\n(CVE-2024-22386)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nphonet: fix rtm_phonet_notify() skb allocation\r\n\r\nfill_route() stores three components in the skb:\r\n\r\n- struct rtmsg\n- RTA_DST (u8)\n- RTA_OIF (u32)\r\n\r\nTherefore, rtm_phonet_notify() should use\r\n\r\nNLMSG_ALIGN(sizeof(struct rtmsg)) +\nnla_total_size(1) +\nnla_total_size(4)(CVE-2024-36946)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nm68k: Fix spinlock race in kernel thread creation\r\n\r\nContext switching does take care to retain the correct lock owner across\nthe switch from &apos;prev&apos; to &apos;next&apos; tasks.  This does rely on interrupts\nremaining disabled for the entire duration of the switch.\r\n\r\nThis condition is guaranteed for normal process creation and context\nswitching between already running processes, because both &apos;prev&apos; and\n&apos;next&apos; already have interrupts disabled in their saved copies of the\nstatus register.\r\n\r\nThe situation is different for newly created kernel threads.  The status\nregister is set to PS_S in copy_thread(), which does leave the IPL at 0.\nUpon restoring the &apos;next&apos; thread&apos;s status register in switch_to() aka\nresume(), interrupts then become enabled prematurely.  resume() then\nreturns via ret_from_kernel_thread() and schedule_tail() where run queue\nlock is released (see finish_task_switch() and finish_lock_switch()).\r\n\r\nA timer interrupt calling scheduler_tick() before the lock is released\nin finish_task_switch() will find the lock already taken, with the\ncurrent task as lock owner.  This causes a spinlock recursion warning as\nreported by Guenter Roeck.\r\n\r\nAs far as I can ascertain, this race has been opened in commit\n533e6903bea0 (&quot;m68k: split ret_from_fork(), simplify kernel_thread()&quot;)\nbut I haven&apos;t done a detailed study of kernel history so it may well\npredate that commit.\r\n\r\nInterrupts cannot be disabled in the saved status register copy for\nkernel threads (init will complain about interrupts disabled when\nfinally starting user space).  Disable interrupts temporarily when\nswitching the tasks&apos; register sets in resume().\r\n\r\nNote that a simple oriw 0x700,%sr after restoring sr is not enough here\n- this leaves enough of a race for the &apos;spinlock recursion&apos; warning to\nstill be observed.\r\n\r\nTested on ARAnyM and qemu (Quadra 800 emulation).(CVE-2024-38613)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nipv6: sr: fix missing sk_buff release in seg6_input_core\r\n\r\nThe seg6_input() function is responsible for adding the SRH into a\npacket, delegating the operation to the seg6_input_core(). This function\nuses the skb_cow_head() to ensure that there is sufficient headroom in\nthe sk_buff for accommodating the link-layer header.\nIn the event that the skb_cow_header() function fails, the\nseg6_input_core() catches the error but it does not release the sk_buff,\nwhich will result in a memory leak.\r\n\r\nThis issue was introduced in commit af3b5158b89d (&quot;ipv6: sr: fix BUG due\nto headroom too small after SRH push&quot;) and persists even after commit\n7a3f5b0de364 (&quot;netfilter: add netfilter hooks to SRv6 data plane&quot;),\nwhere the entire seg6_input() code was refactored to deal with netfilter\nhooks.\r\n\r\nThe proposed patch addresses the identified memory leak by requiring the\nseg6_input_core() function to release the sk_buff in the event that\nskb_cow_head() fails.(CVE-2024-39490)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ncrypto: hisilicon/sec - Fix memory leak for sec resource release\r\n\r\nThe AIV is one of the SEC resources. When releasing resources,\nit need to release the AIV resources at the same time.\nOtherwise, memory leakage occurs.\r\n\r\nThe aiv resource release is added to the sec resource release\nfunction.(CVE-2024-41002)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ns390/sclp: Fix sclp_init() cleanup on failure\r\n\r\nIf sclp_init() fails it only partially cleans up: if there are multiple\nfailing calls to sclp_init() sclp_state_change_event will be added several\ntimes to sclp_reg_list, which results in the following warning:\r\n\r\n------------[ cut here ]------------\nlist_add double add: new=000003ffe1598c10, prev=000003ffe1598bf0, next=000003ffe1598c10.\nWARNING: CPU: 0 PID: 1 at lib/list_debug.c:35 __list_add_valid_or_report+0xde/0xf8\nCPU: 0 PID: 1 Comm: swapper/0 Not tainted 6.10.0-rc3\nKrnl PSW : 0404c00180000000 000003ffe0d6076a (__list_add_valid_or_report+0xe2/0xf8)\n           R:0 T:1 IO:0 EX:0 Key:0 M:1 W:0 P:0 AS:3 CC:0 PM:0 RI:0 EA:3\n...\nCall Trace:\n [&lt;000003ffe0d6076a&gt;] __list_add_valid_or_report+0xe2/0xf8\n([&lt;000003ffe0d60766&gt;] __list_add_valid_or_report+0xde/0xf8)\n [&lt;000003ffe0a8d37e&gt;] sclp_init+0x40e/0x450\n [&lt;000003ffe00009f2&gt;] do_one_initcall+0x42/0x1e0\n [&lt;000003ffe15b77a6&gt;] do_initcalls+0x126/0x150\n [&lt;000003ffe15b7a0a&gt;] kernel_init_freeable+0x1ba/0x1f8\n [&lt;000003ffe0d6650e&gt;] kernel_init+0x2e/0x180\n [&lt;000003ffe000301c&gt;] __ret_from_fork+0x3c/0x60\n [&lt;000003ffe0d759ca&gt;] ret_from_fork+0xa/0x30\r\n\r\nFix this by removing sclp_state_change_event from sclp_reg_list when\nsclp_init() fails.(CVE-2024-41068)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/amd/display: Check pipe offset before setting vblank\r\n\r\npipe_ctx has a size of MAX_PIPES so checking its index before accessing\nthe array.\r\n\r\nThis fixes an OVERRUN issue reported by Coverity.(CVE-2024-42120)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/amd/display: Add NULL pointer check for kzalloc\r\n\r\n[Why &amp; How]\nCheck return pointer of kzalloc before using it.(CVE-2024-42122)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nprotect the fetch of -&gt;fd[fd] in do_dup2() from mispredictions\r\n\r\nboth callers have verified that fd is not greater than -&gt;max_fds;\nhowever, misprediction might end up with\n        tofree = fdt-&gt;fd[fd];\nbeing speculatively executed.  That&apos;s wrong for the same reasons\nwhy it&apos;s wrong in close_fd()/file_close_fd_locked(); the same\nsolution applies - array_index_nospec(fd, fdt-&gt;max_fds) could differ\nfrom fd only in case of speculative execution on mispredicted path.(CVE-2024-42265)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnet/iucv: fix use after free in iucv_sock_close()\r\n\r\niucv_sever_path() is called from process context and from bh context.\niucv-&gt;path is used as indicator whether somebody else is taking care of\nsevering the path (or it is already removed / never existed).\nThis needs to be done with atomic compare and swap, otherwise there is a\nsmall window where iucv_sock_close() will try to work with a path that has\nalready been severed and freed by iucv_callback_connrej() called by\niucv_tasklet_fn().\r\n\r\nExample:\n[452744.123844] Call Trace:\n[452744.123845] ([&lt;0000001e87f03880&gt;] 0x1e87f03880)\n[452744.123966]  [&lt;00000000d593001e&gt;] iucv_path_sever+0x96/0x138\n[452744.124330]  [&lt;000003ff801ddbca&gt;] iucv_sever_path+0xc2/0xd0 [af_iucv]\n[452744.124336]  [&lt;000003ff801e01b6&gt;] iucv_sock_close+0xa6/0x310 [af_iucv]\n[452744.124341]  [&lt;000003ff801e08cc&gt;] iucv_sock_release+0x3c/0xd0 [af_iucv]\n[452744.124345]  [&lt;00000000d574794e&gt;] __sock_release+0x5e/0xe8\n[452744.124815]  [&lt;00000000d5747a0c&gt;] sock_close+0x34/0x48\n[452744.124820]  [&lt;00000000d5421642&gt;] __fput+0xba/0x268\n[452744.124826]  [&lt;00000000d51b382c&gt;] task_work_run+0xbc/0xf0\n[452744.124832]  [&lt;00000000d5145710&gt;] do_notify_resume+0x88/0x90\n[452744.124841]  [&lt;00000000d5978096&gt;] system_call+0xe2/0x2c8\n[452744.125319] Last Breaking-Event-Address:\n[452744.125321]  [&lt;00000000d5930018&gt;] iucv_path_sever+0x90/0x138\n[452744.125324]\n[452744.125325] Kernel panic - not syncing: Fatal exception in interrupt\r\n\r\nNote that bh_lock_sock() is not serializing the tasklet context against\nprocess context, because the check for sock_owned_by_user() and\ncorresponding handling is missing.\r\n\r\nIdeas for a future clean-up patch:\nA) Correct usage of bh_lock_sock() in tasklet context, as described in\nRe-enqueue, if needed. This may require adding return values to the\ntasklet functions and thus changes to all users of iucv.\r\n\r\nB) Change iucv tasklet into worker and use only lock_sock() in af_iucv.(CVE-2024-42271)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nmISDN: Fix a use after free in hfcmulti_tx()\r\n\r\nDon&apos;t dereference *sp after calling dev_kfree_skb(*sp).(CVE-2024-42280)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nbpf: Fix a segment issue when downgrading gso_size\r\n\r\nLinearize the skb when downgrading gso_size because it may trigger a\nBUG_ON() later when the skb is segmented as described in [1,2].(CVE-2024-42281)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ntipc: Return non-zero value from tipc_udp_addr2str() on error\r\n\r\ntipc_udp_addr2str() should return non-zero value if the UDP media\naddress is invalid. Otherwise, a buffer overflow access can occur in\ntipc_media_addr_printf(). Fix this by returning 1 on an invalid UDP\nmedia address.(CVE-2024-42284)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nRDMA/iwcm: Fix a use-after-free related to destroying CM IDs\r\n\r\niw_conn_req_handler() associates a new struct rdma_id_private (conn_id) with\nan existing struct iw_cm_id (cm_id) as follows:\r\n\r\n        conn_id-&gt;cm_id.iw = cm_id;\n        cm_id-&gt;context = conn_id;\n        cm_id-&gt;cm_handler = cma_iw_handler;\r\n\r\nrdma_destroy_id() frees both the cm_id and the struct rdma_id_private. Make\nsure that cm_work_handler() does not trigger a use-after-free by only\nfreeing of the struct rdma_id_private after all pending work has finished.(CVE-2024-42285)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nf2fs: fix to don&apos;t dirty inode for readonly filesystem\r\n\r\nsyzbot reports f2fs bug as below:\r\n\r\nkernel BUG at fs/f2fs/inode.c:933!\nRIP: 0010:f2fs_evict_inode+0x1576/0x1590 fs/f2fs/inode.c:933\nCall Trace:\n evict+0x2a4/0x620 fs/inode.c:664\n dispose_list fs/inode.c:697 [inline]\n evict_inodes+0x5f8/0x690 fs/inode.c:747\n generic_shutdown_super+0x9d/0x2c0 fs/super.c:675\n kill_block_super+0x44/0x90 fs/super.c:1667\n kill_f2fs_super+0x303/0x3b0 fs/f2fs/super.c:4894\n deactivate_locked_super+0xc1/0x130 fs/super.c:484\n cleanup_mnt+0x426/0x4c0 fs/namespace.c:1256\n task_work_run+0x24a/0x300 kernel/task_work.c:180\n ptrace_notify+0x2cd/0x380 kernel/signal.c:2399\n ptrace_report_syscall include/linux/ptrace.h:411 [inline]\n ptrace_report_syscall_exit include/linux/ptrace.h:473 [inline]\n syscall_exit_work kernel/entry/common.c:251 [inline]\n syscall_exit_to_user_mode_prepare kernel/entry/common.c:278 [inline]\n __syscall_exit_to_user_mode_work kernel/entry/common.c:283 [inline]\n syscall_exit_to_user_mode+0x15c/0x280 kernel/entry/common.c:296\n do_syscall_64+0x50/0x110 arch/x86/entry/common.c:88\n entry_SYSCALL_64_after_hwframe+0x63/0x6b\r\n\r\nThe root cause is:\n- do_sys_open\n - f2fs_lookup\n  - __f2fs_find_entry\n   - f2fs_i_depth_write\n    - f2fs_mark_inode_dirty_sync\n     - f2fs_dirty_inode\n      - set_inode_flag(inode, FI_DIRTY_INODE)\r\n\r\n- umount\n - kill_f2fs_super\n  - kill_block_super\n   - generic_shutdown_super\n    - sync_filesystem\n    : sb is readonly, skip sync_filesystem()\n    - evict_inodes\n     - iput\n      - f2fs_evict_inode\n       - f2fs_bug_on(sbi, is_inode_flag_set(inode, FI_DIRTY_INODE))\n       : trigger kernel panic\r\n\r\nWhen we try to repair i_current_depth in readonly filesystem, let&apos;s\nskip dirty inode to avoid panic in later f2fs_evict_inode().(CVE-2024-42297)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\next4: check dot and dotdot of dx_root before making dir indexed\r\n\r\nSyzbot reports a issue as follows:\n============================================\nBUG: unable to handle page fault for address: ffffed11022e24fe\nPGD 23ffee067 P4D 23ffee067 PUD 0\nOops: Oops: 0000 [#1] PREEMPT SMP KASAN PTI\nCPU: 0 PID: 5079 Comm: syz-executor306 Not tainted 6.10.0-rc5-g55027e689933 #0\nCall Trace:\n &lt;TASK&gt;\n make_indexed_dir+0xdaf/0x13c0 fs/ext4/namei.c:2341\n ext4_add_entry+0x222a/0x25d0 fs/ext4/namei.c:2451\n ext4_rename fs/ext4/namei.c:3936 [inline]\n ext4_rename2+0x26e5/0x4370 fs/ext4/namei.c:4214\n[...]\n============================================\r\n\r\nThe immediate cause of this problem is that there is only one valid dentry\nfor the block to be split during do_split, so split==0 results in out of\nbounds accesses to the map triggering the issue.\r\n\r\n    do_split\n      unsigned split\n      dx_make_map\n       count = 1\n      split = count/2 = 0;\n      continued = hash2 == map[split - 1].hash;\n       ---&gt; map[4294967295]\r\n\r\nThe maximum length of a filename is 255 and the minimum block size is 1024,\nso it is always guaranteed that the number of entries is greater than or\nequal to 2 when do_split() is called.\r\n\r\nBut syzbot&apos;s crafted image has no dot and dotdot in dir, and the dentry\ndistribution in dirblock is as follows:\r\n\r\n  bus     dentry1          hole           dentry2           free\n|xx--|xx-------------|...............|xx-------------|...............|\n0   12 (8+248)=256  268     256     524 (8+256)=264 788     236     1024\r\n\r\nSo when renaming dentry1 increases its name_len length by 1, neither hole\nnor free is sufficient to hold the new dentry, and make_indexed_dir() is\ncalled.\r\n\r\nIn make_indexed_dir() it is assumed that the first two entries of the\ndirblock must be dot and dotdot, so bus and dentry1 are left in dx_root\nbecause they are treated as dot and dotdot, and only dentry2 is moved\nto the new leaf block. That&apos;s why count is equal to 1.\r\n\r\nTherefore add the ext4_check_dx_root() helper function to add more sanity\nchecks to dot and dotdot before starting the conversion to avoid the above\nissue.(CVE-2024-42305)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ndrm/amd/display: Check for NULL pointer\r\n\r\n[why &amp; how]\nNeed to make sure plane_state is initialized\nbefore accessing its members.\r\n\r\n(cherry picked from commit 295d91cbc700651782a60572f83c24861607b648)(CVE-2024-42308)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nkvm: s390: Reject memory region operations for ucontrol VMs\r\n\r\nThis change rejects the KVM_SET_USER_MEMORY_REGION and\nKVM_SET_USER_MEMORY_REGION2 ioctls when called on a ucontrol VM.\nThis is necessary since ucontrol VMs have kvm-&gt;arch.gmap set to 0 and\nwould thus result in a null pointer dereference further in.\nMemory management needs to be performed in userspace and using the\nioctls KVM_S390_UCAS_MAP and KVM_S390_UCAS_UNMAP.\r\n\r\nAlso improve s390 specific documentation for KVM_SET_USER_MEMORY_REGION\nand KVM_SET_USER_MEMORY_REGION2.\r\n\r\n[frankja@linux.ibm.com: commit message spelling fix, subject prefix fix](CVE-2024-43819)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\next4: fix infinite loop when replaying fast_commit\r\n\r\nWhen doing fast_commit replay an infinite loop may occur due to an\nuninitialized extent_status struct.  ext4_ext_determine_insert_hole() does\nnot detect the replay and calls ext4_es_find_extent_range(), which will\nreturn immediately without initializing the &apos;es&apos; variable.\r\n\r\nBecause &apos;es&apos; contains garbage, an integer overflow may happen causing an\ninfinite loop in this function, easily reproducible using fstest generic/039.\r\n\r\nThis commit fixes this issue by unconditionally initializing the structure\nin function ext4_es_find_extent_range().\r\n\r\nThanks to Zhang Yi, for figuring out the real problem!(CVE-2024-43828)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nmedia: mediatek: vcodec: Handle invalid decoder vsi\r\n\r\nHandle an invalid decoder vsi in vpu_dec_init to ensure the decoder vsi\nis valid for future use.(CVE-2024-43831)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ncgroup/cpuset: Prevent UAF in proc_cpuset_show()\r\n\r\nAn UAF can happen when /proc/cpuset is read as reported in [1].\r\n\r\nThis can be reproduced by the following methods:\n1.add an mdelay(1000) before acquiring the cgroup_lock In the\n cgroup_path_ns function.\n2.$cat /proc/&lt;pid&gt;/cpuset   repeatly.\n3.$mount -t cgroup -o cpuset cpuset /sys/fs/cgroup/cpuset/\n$umount /sys/fs/cgroup/cpuset/   repeatly.\r\n\r\nThe race that cause this bug can be shown as below:\r\n\r\n(umount)\t\t|\t(cat /proc/&lt;pid&gt;/cpuset)\ncss_release\t\t|\tproc_cpuset_show\ncss_release_work_fn\t|\tcss = task_get_css(tsk, cpuset_cgrp_id);\ncss_free_rwork_fn\t|\tcgroup_path_ns(css-&gt;cgroup, ...);\ncgroup_destroy_root\t|\tmutex_lock(&amp;cgroup_mutex);\nrebind_subsystems\t|\ncgroup_free_root \t|\n\t\t\t|\t// cgrp was freed, UAF\n\t\t\t|\tcgroup_path_ns_locked(cgrp,..);\r\n\r\nWhen the cpuset is initialized, the root node top_cpuset.css.cgrp\nwill point to &amp;cgrp_dfl_root.cgrp. In cgroup v1, the mount operation will\nallocate cgroup_root, and top_cpuset.css.cgrp will point to the allocated\n&amp;cgroup_root.cgrp. When the umount operation is executed,\ntop_cpuset.css.cgrp will be rebound to &amp;cgrp_dfl_root.cgrp.\r\n\r\nThe problem is that when rebinding to cgrp_dfl_root, there are cases\nwhere the cgroup_root allocated by setting up the root for cgroup v1\nis cached. This could lead to a Use-After-Free (UAF) if it is\nsubsequently freed. The descendant cgroups of cgroup v1 can only be\nfreed after the css is released. However, the css of the root will never\nbe released, yet the cgroup_root should be freed when it is unmounted.\nThis means that obtaining a reference to the css of the root does\nnot guarantee that css.cgrp-&gt;root will not be freed.\r\n\r\nFix this problem by using rcu_read_lock in proc_cpuset_show().\nAs cgroup_root is kfree_rcu after commit d23b5c577715\n(&quot;cgroup: Make operations on the cgroup root_list RCU safe&quot;),\ncss-&gt;cgroup won&apos;t be freed during the critical section.\nTo call cgroup_path_ns_locked, css_set_lock is needed, so it is safe to\nreplace task_get_css with task_css.\r\n\r\n[1] https://syzkaller.appspot.com/bug?extid=9b1ff7be974a403aa4cd(CVE-2024-43853)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nremoteproc: imx_rproc: Skip over memory region when node value is NULL\r\n\r\nIn imx_rproc_addr_init() &quot;nph = of_count_phandle_with_args()&quot; just counts\nnumber of phandles. But phandles may be empty. So of_parse_phandle() in\nthe parsing loop (0 &lt; a &lt; nph) may return NULL which is later dereferenced.\nAdjust this issue by adding NULL-return check.\r\n\r\nFound by Linux Verification Center (linuxtesting.org) with SVACE.\r\n\r\n[Fixed title to fit within the prescribed 70-75 charcters](CVE-2024-43860)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnet: usb: qmi_wwan: fix memory leak for not ip packets\r\n\r\nFree the unused skb when not ip packets arrive.(CVE-2024-43861)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnet/mlx5: Always drain health in shutdown callback\r\n\r\nThere is no point in recovery during device shutdown. if health\nwork started need to wait for it to avoid races and NULL pointer\naccess.\r\n\r\nHence, drain health WQ on shutdown callback.(CVE-2024-43866)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nwifi: cfg80211: handle 2x996 RU allocation in cfg80211_calculate_bitrate_he()\r\n\r\nCurrently NL80211_RATE_INFO_HE_RU_ALLOC_2x996 is not handled in\ncfg80211_calculate_bitrate_he(), leading to below warning:\r\n\r\nkernel: invalid HE MCS: bw:6, ru:6\nkernel: WARNING: CPU: 0 PID: 2312 at net/wireless/util.c:1501 cfg80211_calculate_bitrate_he+0x22b/0x270 [cfg80211]\r\n\r\nFix it by handling 2x996 RU allocation in the same way as 160 MHz bandwidth.(CVE-2024-43879)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nexec: Fix ToCToU between perm check and set-uid/gid usage\r\n\r\nWhen opening a file for exec via do_filp_open(), permission checking is\ndone against the file&apos;s metadata at that moment, and on success, a file\npointer is passed back. Much later in the execve() code path, the file\nmetadata (specifically mode, uid, and gid) is used to determine if/how\nto set the uid and gid. However, those values may have changed since the\npermissions check, meaning the execution may gain unintended privileges.\r\n\r\nFor example, if a file could change permissions from executable and not\nset-id:\r\n\r\n---------x 1 root root 16048 Aug  7 13:16 target\r\n\r\nto set-id and non-executable:\r\n\r\n---S------ 1 root root 16048 Aug  7 13:16 target\r\n\r\nit is possible to gain root privileges when execution should have been\ndisallowed.\r\n\r\nWhile this race condition is rare in real-world scenarios, it has been\nobserved (and proven exploitable) when package managers are updating\nthe setuid bits of installed programs. Such files start with being\nworld-executable but then are adjusted to be group-exec with a set-uid\nbit. For example, &quot;chmod o-x,u+s target&quot; makes &quot;target&quot; executable only\nby uid &quot;root&quot; and gid &quot;cdrom&quot;, while also becoming setuid-root:\r\n\r\n-rwxr-xr-x 1 root cdrom 16048 Aug  7 13:16 target\r\n\r\nbecomes:\r\n\r\n-rwsr-xr-- 1 root cdrom 16048 Aug  7 13:16 target\r\n\r\nBut racing the chmod means users without group &quot;cdrom&quot; membership can\nget the permission to execute &quot;target&quot; just before the chmod, and when\nthe chmod finishes, the exec reaches brpm_fill_uid(), and performs the\nsetuid to root, violating the expressed authorization of &quot;only cdrom\ngroup members can setuid to root&quot;.\r\n\r\nRe-check that we still have execute permissions in case the metadata\nhas changed. It would be better to keep a copy from the perm-check time,\nbut until we can do that refactoring, the least-bad option is to do a\nfull inode_permission() call (under inode lock). It is understood that\nthis is safe against dead-locks, but hardly optimal.(CVE-2024-43882)","affected":[{"package":{"name":"kernel","ecosystem":"openEuler:22.03-LTS-SP1","purl":"pkg:rpm/openEuler/kernel&distro=openEuler-22.03-LTS-SP1"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"5.10.0-136.91.0.172.oe2203sp1"}]}],"ecosystem_specific":{"aarch64":["kernel-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-debuginfo-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-debugsource-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-devel-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-headers-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-source-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-tools-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-tools-debuginfo-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","kernel-tools-devel-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","perf-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","perf-debuginfo-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","python3-perf-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm","python3-perf-debuginfo-5.10.0-136.91.0.172.oe2203sp1.aarch64.rpm"],"src":["kernel-5.10.0-136.91.0.172.oe2203sp1.src.rpm"],"x86_64":["kernel-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-debuginfo-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-debugsource-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-devel-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-headers-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-source-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-tools-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-tools-debuginfo-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","kernel-tools-devel-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","perf-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","perf-debuginfo-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","python3-perf-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm","python3-perf-debuginfo-5.10.0-136.91.0.172.oe2203sp1.x86_64.rpm"]},"database_specific":{"source":"https://repo.openeuler.org/security/data/osv/OESA-2024-2080.json"}}],"references":[{"type":"ADVISORY","url":"https://www.openeuler.org/zh/security/security-bulletins/detail/?id=openEuler-SA-2024-2080"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47292"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47504"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47556"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48634"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48639"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48642"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48643"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48644"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48647"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48648"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48656"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48663"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48671"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48672"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48675"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48686"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48687"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48691"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48873"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48896"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48898"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48899"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48920"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2022-48935"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-52893"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-52898"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-52901"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-52903"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-22386"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-36946"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-38613"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-39490"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-41002"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-41068"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42120"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42122"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42265"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42271"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42280"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42281"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42284"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42285"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42297"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42305"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-42308"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43819"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43828"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43831"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43853"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43860"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43861"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43866"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43879"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2024-43882"}],"database_specific":{"severity":"High"}}