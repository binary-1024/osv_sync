{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2025-21827.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.13-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2025-21827.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.13-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  Bluetooth: btusb: mediatek: Add locks for usb_driver_claim_interface()  The documentation for usb_driver_claim_interface() says that \"the device lock\" is needed when the function is called from places other than probe(). This appears to be the lock for the USB interface device. The Mediatek btusb code gets called via this path:    Workqueue: hci0 hci_power_on [bluetooth]   Call trace:    usb_driver_claim_interface    btusb_mtk_claim_iso_intf    btusb_mtk_setup    hci_dev_open_sync    hci_power_on    process_scheduled_works    worker_thread    kthread  With the above call trace the device lock hasn't been claimed. Claim it.  Without this fix, we'd sometimes see the error \"Failed to claim iso interface\". Sometimes we'd even see worse errors, like a NULL pointer dereference (where `intf->dev.driver` was NULL) with a trace like:    Call trace:    usb_suspend_both    usb_runtime_suspend    __rpm_callback    rpm_suspend    pm_runtime_work    process_scheduled_works  Both errors appear to be fixed with the proper locking.",
  "id": "DEBIAN-CVE-2025-21827",
  "modified": "2025-09-24T00:03:58Z",
  "published": "2025-03-06T16:15:54Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2025-21827"
    }
  ],
  "schema_version": "1.7.3"
}