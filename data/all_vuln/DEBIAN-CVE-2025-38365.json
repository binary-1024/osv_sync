{
  "affected": [
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2025-38365.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:12",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.1.147-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": [
        "6.1.106-1",
        "6.1.106-2",
        "6.1.106-3",
        "6.1.112-1",
        "6.1.115-1",
        "6.1.119-1",
        "6.1.123-1",
        "6.1.124-1",
        "6.1.128-1",
        "6.1.129-1",
        "6.1.133-1",
        "6.1.135-1",
        "6.1.137-1",
        "6.1.139-1",
        "6.1.140-1",
        "6.1.27-1",
        "6.1.37-1",
        "6.1.38-1",
        "6.1.38-2",
        "6.1.38-2~bpo11+1",
        "6.1.38-3",
        "6.1.38-4",
        "6.1.38-4~bpo11+1",
        "6.1.52-1",
        "6.1.55-1",
        "6.1.55-1~bpo11+1",
        "6.1.64-1",
        "6.1.66-1",
        "6.1.67-1",
        "6.1.69-1",
        "6.1.69-1~bpo11+1",
        "6.1.76-1",
        "6.1.76-1~bpo11+1",
        "6.1.82-1",
        "6.1.85-1",
        "6.1.90-1",
        "6.1.90-1~bpo11+1",
        "6.1.94-1",
        "6.1.94-1~bpo11+1",
        "6.1.98-1",
        "6.1.99-1"
      ]
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2025-38365.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:13",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.37-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    },
    {
      "database_specific": {
        "source": "https://storage.googleapis.com/debian-osv/debian-cve-osv/DEBIAN-CVE-2025-38365.json"
      },
      "ecosystem_specific": {
        "urgency": "not yet assigned"
      },
      "package": {
        "ecosystem": "Debian:14",
        "name": "linux",
        "purl": "pkg:deb/debian/linux?arch=source"
      },
      "ranges": [
        {
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "6.12.37-1"
            }
          ],
          "type": "ECOSYSTEM"
        }
      ],
      "versions": []
    }
  ],
  "details": "In the Linux kernel, the following vulnerability has been resolved:  btrfs: fix a race between renames and directory logging  We have a race between a rename and directory inode logging that if it happens and we crash/power fail before the rename completes, the next time the filesystem is mounted, the log replay code will end up deleting the file that was being renamed.  This is best explained following a step by step analysis of an interleaving of steps that lead into this situation.  Consider the initial conditions:  1) We are at transaction N;  2) We have directories A and B created in a past transaction (< N);  3) We have inode X corresponding to a file that has 2 hardlinks, one in    directory A and the other in directory B, so we'll name them as    \"A/foo_link1\" and \"B/foo_link2\". Both hard links were persisted in a    past transaction (< N);  4) We have inode Y corresponding to a file that as a single hard link and    is located in directory A, we'll name it as \"A/bar\". This file was also    persisted in a past transaction (< N).  The steps leading to a file loss are the following and for all of them we are under transaction N:   1) Link \"A/foo_link1\" is removed, so inode's X last_unlink_trans field     is updated to N, through btrfs_unlink() -> btrfs_record_unlink_dir();   2) Task A starts a rename for inode Y, with the goal of renaming from     \"A/bar\" to \"A/baz\", so we enter btrfs_rename();   3) Task A inserts the new BTRFS_INODE_REF_KEY for inode Y by calling     btrfs_insert_inode_ref();   4) Because the rename happens in the same directory, we don't set the     last_unlink_trans field of directoty A's inode to the current     transaction id, that is, we don't cal btrfs_record_unlink_dir();   5) Task A then removes the entries from directory A (BTRFS_DIR_ITEM_KEY     and BTRFS_DIR_INDEX_KEY items) when calling __btrfs_unlink_inode()     (actually the dir index item is added as a delayed item, but the     effect is the same);   6) Now before task A adds the new entry \"A/baz\" to directory A by     calling btrfs_add_link(), another task, task B is logging inode X;   7) Task B starts a fsync of inode X and after logging inode X, at     btrfs_log_inode_parent() it calls btrfs_log_all_parents(), since     inode X has a last_unlink_trans value of N, set at in step 1;   8) At btrfs_log_all_parents() we search for all parent directories of     inode X using the commit root, so we find directories A and B and log     them. Bu when logging direct A, we don't have a dir index item for     inode Y anymore, neither the old name \"A/bar\" nor for the new name     \"A/baz\" since the rename has deleted the old name but has not yet     inserted the new name - task A hasn't called yet btrfs_add_link() to     do that.      Note that logging directory A doesn't fallback to a transaction     commit because its last_unlink_trans has a lower value than the     current transaction's id (see step 4);   9) Task B finishes logging directories A and B and gets back to     btrfs_sync_file() where it calls btrfs_sync_log() to persist the log     tree;  10) Task B successfully persisted the log tree, btrfs_sync_log() completed     with success, and a power failure happened.      We have a log tree without any directory entry for inode Y, so the     log replay code deletes the entry for inode Y, name \"A/bar\", from the     subvolume tree since it doesn't exist in the log tree and the log     tree is authorative for its index (we logged a BTRFS_DIR_LOG_INDEX_KEY     item that covers the index range for the dentry that corresponds to     \"A/bar\").      Since there's no other hard link for inode Y and the log replay code     deletes the name \"A/bar\", the file is lost.  The issue wouldn't happen if task B synced the log only after task A called btrfs_log_new_name(), which would update the log with the new name for inode Y (\"A/bar\").  Fix this by pinning the log root during renames before removing the old directory entry, and unpinning af ---truncated---",
  "id": "DEBIAN-CVE-2025-38365",
  "modified": "2025-09-30T05:20:41.484547Z",
  "published": "2025-07-25T13:15:25Z",
  "references": [
    {
      "type": "ADVISORY",
      "url": "https://security-tracker.debian.org/tracker/CVE-2025-38365"
    }
  ],
  "schema_version": "1.7.3",
  "upstream": [
    "CVE-2025-38365"
  ]
}