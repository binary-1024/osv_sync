{"schema_version":"1.7.3","id":"OESA-2024-1345","published":"2024-03-29T11:07:20Z","modified":"2025-09-03T06:17:10.587512Z","upstream":["CVE-2020-36778","CVE-2020-36782","CVE-2021-46906","CVE-2021-46909","CVE-2021-46941","CVE-2021-46955","CVE-2021-46998","CVE-2021-47006","CVE-2021-47013","CVE-2021-47015","CVE-2021-47024","CVE-2021-47040","CVE-2021-47049","CVE-2023-52458","CVE-2023-52528","CVE-2023-52604"],"summary":"kernel security update","details":"The Linux Kernel, the operating system core itself.\r\n\r\nSecurity Fix(es):\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ni2c: xiic: fix reference leak when pm_runtime_get_sync fails\r\n\r\nThe PM reference count is not expected to be incremented on\nreturn in xiic_xfer and xiic_i2c_remove.\r\n\r\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\r\n\r\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.(CVE-2020-36778)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\ni2c: imx-lpi2c: fix reference leak when pm_runtime_get_sync fails\r\n\r\nThe PM reference count is not expected to be incremented on\nreturn in lpi2c_imx_master_enable.\r\n\r\nHowever, pm_runtime_get_sync will increment the PM reference\ncount even failed. Forgetting to putting operation will result\nin a reference leak here.\r\n\r\nReplace it with pm_runtime_resume_and_get to keep usage\ncounter balanced.(CVE-2020-36782)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nHID: usbhid: fix info leak in hid_submit_ctrl\r\n\r\nIn hid_submit_ctrl(), the way of calculating the report length doesn&apos;t\ntake into account that report-&gt;size can be zero. When running the\nsyzkaller reproducer, a report of size 0 causes hid_submit_ctrl) to\ncalculate transfer_buffer_length as 16384. When this urb is passed to\nthe usb core layer, KMSAN reports an info leak of 16384 bytes.\r\n\r\nTo fix this, first modify hid_report_len() to account for the zero\nreport size case by using DIV_ROUND_UP for the division. Then, call it\nfrom hid_submit_ctrl().(CVE-2021-46906)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nARM: footbridge: fix PCI interrupt mapping\r\n\r\nSince commit 30fdfb929e82 (&quot;PCI: Add a call to pci_assign_irq() in\npci_device_probe()&quot;), the PCI code will call the IRQ mapping function\nwhenever a PCI driver is probed. If these are marked as __init, this\ncauses an oops if a PCI driver is loaded or bound after the kernel has\ninitialised.(CVE-2021-46909)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nusb: dwc3: core: Do core softreset when switch mode\r\n\r\n\nAccording to the programming guide, to switch mode for DRD controller,\nthe driver needs to do the following.\r\n\r\nTo switch from device to host:\n1. Reset controller with GCTL.CoreSoftReset\n2. Set GCTL.PrtCapDir(host mode)\n3. Reset the host with USBCMD.HCRESET\n4. Then follow up with the initializing host registers sequence\r\n\r\nTo switch from host to device:\n1. Reset controller with GCTL.CoreSoftReset\n2. Set GCTL.PrtCapDir(device mode)\n3. Reset the device with DCTL.CSftRst\n4. Then follow up with the initializing registers sequence\r\n\r\nCurrently we&apos;re missing step 1) to do GCTL.CoreSoftReset and step 3) of\nswitching from host to device. John Stult reported a lockup issue seen\nwith HiKey960 platform without these steps[1]. Similar issue is observed\nwith Ferry&apos;s testing platform[2].\r\n\r\nSo, apply the required steps along with some fixes to Yu Chen&apos;s and John\nStultz&apos;s version. The main fixes to their versions are the missing wait\nfor clocks synchronization before clearing GCTL.CoreSoftReset and only\napply DCTL.CSftRst when switching from host to device.\r\n\r\n[1] https://lore.kernel.org/linux-usb/20210108015115.27920-1-john.stultz@linaro.org/\n[2] https://lore.kernel.org/linux-usb/0ba7a6ba-e6a7-9cd4-0695-64fc927e01f1@gmail.com/(CVE-2021-46941)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nopenvswitch: fix stack OOB read while fragmenting IPv4 packets\r\n\r\nrunning openvswitch on kernels built with KASAN, it&apos;s possible to see the\nfollowing splat while testing fragmentation of IPv4 packets:\r\n\r\n BUG: KASAN: stack-out-of-bounds in ip_do_fragment+0x1b03/0x1f60\n Read of size 1 at addr ffff888112fc713c by task handler2/1367\r\n\r\n CPU: 0 PID: 1367 Comm: handler2 Not tainted 5.12.0-rc6+ #418\n Hardware name: Red Hat KVM, BIOS 1.11.1-4.module+el8.1.0+4066+0f1aadab 04/01/2014\n Call Trace:\n  dump_stack+0x92/0xc1\n  print_address_description.constprop.7+0x1a/0x150\n  kasan_report.cold.13+0x7f/0x111\n  ip_do_fragment+0x1b03/0x1f60\n  ovs_fragment+0x5bf/0x840 [openvswitch]\n  do_execute_actions+0x1bd5/0x2400 [openvswitch]\n  ovs_execute_actions+0xc8/0x3d0 [openvswitch]\n  ovs_packet_cmd_execute+0xa39/0x1150 [openvswitch]\n  genl_family_rcv_msg_doit.isra.15+0x227/0x2d0\n  genl_rcv_msg+0x287/0x490\n  netlink_rcv_skb+0x120/0x380\n  genl_rcv+0x24/0x40\n  netlink_unicast+0x439/0x630\n  netlink_sendmsg+0x719/0xbf0\n  sock_sendmsg+0xe2/0x110\n  ____sys_sendmsg+0x5ba/0x890\n  ___sys_sendmsg+0xe9/0x160\n  __sys_sendmsg+0xd3/0x170\n  do_syscall_64+0x33/0x40\n  entry_SYSCALL_64_after_hwframe+0x44/0xae\n RIP: 0033:0x7f957079db07\n Code: c3 66 90 41 54 41 89 d4 55 48 89 f5 53 89 fb 48 83 ec 10 e8 eb ec ff ff 44 89 e2 48 89 ee 89 df 41 89 c0 b8 2e 00 00 00 0f 05 &lt;48&gt; 3d 00 f0 ff ff 77 35 44 89 c7 48 89 44 24 08 e8 24 ed ff ff 48\n RSP: 002b:00007f956ce35a50 EFLAGS: 00000293 ORIG_RAX: 000000000000002e\n RAX: ffffffffffffffda RBX: 0000000000000019 RCX: 00007f957079db07\n RDX: 0000000000000000 RSI: 00007f956ce35ae0 RDI: 0000000000000019\n RBP: 00007f956ce35ae0 R08: 0000000000000000 R09: 00007f9558006730\n R10: 0000000000000000 R11: 0000000000000293 R12: 0000000000000000\n R13: 00007f956ce37308 R14: 00007f956ce35f80 R15: 00007f956ce35ae0\r\n\r\n The buggy address belongs to the page:\n page:00000000af2a1d93 refcount:0 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x112fc7\n flags: 0x17ffffc0000000()\n raw: 0017ffffc0000000 0000000000000000 dead000000000122 0000000000000000\n raw: 0000000000000000 0000000000000000 00000000ffffffff 0000000000000000\n page dumped because: kasan: bad access detected\r\n\r\n addr ffff888112fc713c is located in stack of task handler2/1367 at offset 180 in frame:\n  ovs_fragment+0x0/0x840 [openvswitch]\r\n\r\n this frame has 2 objects:\n  [32, 144) &apos;ovs_dst&apos;\n  [192, 424) &apos;ovs_rt&apos;\r\n\r\n Memory state around the buggy address:\n  ffff888112fc7000: f3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  ffff888112fc7080: 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00 00 00 00\n &gt;ffff888112fc7100: 00 00 00 f2 f2 f2 f2 f2 f2 00 00 00 00 00 00 00\n                                         ^\n  ffff888112fc7180: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n  ffff888112fc7200: 00 00 00 00 00 00 f2 f2 f2 00 00 00 00 00 00 00\r\n\r\nfor IPv4 packets, ovs_fragment() uses a temporary struct dst_entry. Then,\nin the following call graph:\r\n\r\n  ip_do_fragment()\n    ip_skb_dst_mtu()\n      ip_dst_mtu_maybe_forward()\n        ip_mtu_locked()\r\n\r\nthe pointer to struct dst_entry is used as pointer to struct rtable: this\nturns the access to struct members like rt_mtu_locked into an OOB read in\nthe stack. Fix this changing the temporary variable used for IPv4 packets\nin ovs_fragment(), similarly to what is done for IPv6 few lines below.(CVE-2021-46955)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nethernet:enic: Fix a use after free bug in enic_hard_start_xmit\r\n\r\nIn enic_hard_start_xmit, it calls enic_queue_wq_skb(). Inside\nenic_queue_wq_skb, if some error happens, the skb will be freed\nby dev_kfree_skb(skb). But the freed skb is still used in\nskb_tx_timestamp(skb).\r\n\r\nMy patch makes enic_queue_wq_skb() return error and goto spin_unlock()\nincase of error. The solution is provided by Govind.\nSee https://lkml.org/lkml/2021/4/30/961.(CVE-2021-46998)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nARM: 9064/1: hw_breakpoint: Do not directly check the event&apos;s overflow_handler hook\r\n\r\nThe commit 1879445dfa7b (&quot;perf/core: Set event&apos;s default\n::overflow_handler()&quot;) set a default event-&gt;overflow_handler in\nperf_event_alloc(), and replace the check event-&gt;overflow_handler with\nis_default_overflow_handler(), but one is missing.\r\n\r\nCurrently, the bp-&gt;overflow_handler can not be NULL. As a result,\nenable_single_step() is always not invoked.\r\n\r\nComments from Zhen Lei:\r\n\r\n https://patchwork.kernel.org/project/linux-arm-kernel/patch/20210207105934.2001-1-thunder.leizhen@huawei.com/(CVE-2021-47006)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnet:emac/emac-mac: Fix a use after free in emac_mac_tx_buf_send\r\n\r\nIn emac_mac_tx_buf_send, it calls emac_tx_fill_tpd(..,skb,..).\nIf some error happens in emac_tx_fill_tpd(), the skb will be freed via\ndev_kfree_skb(skb) in error branch of emac_tx_fill_tpd().\nBut the freed skb is still used via skb-&gt;len by netdev_sent_queue(,skb-&gt;len).\r\n\r\nAs i observed that emac_tx_fill_tpd() haven&apos;t modified the value of skb-&gt;len,\nthus my patch assigns skb-&gt;len to &apos;len&apos; before the possible free and\nuse &apos;len&apos; instead of skb-&gt;len later.(CVE-2021-47013)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nbnxt_en: Fix RX consumer index logic in the error path.\r\n\r\nIn bnxt_rx_pkt(), the RX buffers are expected to complete in order.\nIf the RX consumer index indicates an out of order buffer completion,\nit means we are hitting a hardware bug and the driver will abort all\nremaining RX packets and reset the RX ring.  The RX consumer index\nthat we pass to bnxt_discard_rx() is not correct.  We should be\npassing the current index (tmp_raw_cons) instead of the old index\n(raw_cons).  This bug can cause us to be at the wrong index when\ntrying to abort the next RX packet.  It can crash like this:\r\n\r\n #0 [ffff9bbcdf5c39a8] machine_kexec at ffffffff9b05e007\n #1 [ffff9bbcdf5c3a00] __crash_kexec at ffffffff9b111232\n #2 [ffff9bbcdf5c3ad0] panic at ffffffff9b07d61e\n #3 [ffff9bbcdf5c3b50] oops_end at ffffffff9b030978\n #4 [ffff9bbcdf5c3b78] no_context at ffffffff9b06aaf0\n #5 [ffff9bbcdf5c3bd8] __bad_area_nosemaphore at ffffffff9b06ae2e\n #6 [ffff9bbcdf5c3c28] bad_area_nosemaphore at ffffffff9b06af24\n #7 [ffff9bbcdf5c3c38] __do_page_fault at ffffffff9b06b67e\n #8 [ffff9bbcdf5c3cb0] do_page_fault at ffffffff9b06bb12\n #9 [ffff9bbcdf5c3ce0] page_fault at ffffffff9bc015c5\n    [exception RIP: bnxt_rx_pkt+237]\n    RIP: ffffffffc0259cdd  RSP: ffff9bbcdf5c3d98  RFLAGS: 00010213\n    RAX: 000000005dd8097f  RBX: ffff9ba4cb11b7e0  RCX: ffffa923cf6e9000\n    RDX: 0000000000000fff  RSI: 0000000000000627  RDI: 0000000000001000\n    RBP: ffff9bbcdf5c3e60   R8: 0000000000420003   R9: 000000000000020d\n    R10: ffffa923cf6ec138  R11: ffff9bbcdf5c3e83  R12: ffff9ba4d6f928c0\n    R13: ffff9ba4cac28080  R14: ffff9ba4cb11b7f0  R15: ffff9ba4d5a30000\n    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018(CVE-2021-47015)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nvsock/virtio: free queued packets when closing socket\r\n\r\nAs reported by syzbot [1], there is a memory leak while closing the\nsocket. We partially solved this issue with commit ac03046ece2b\n(&quot;vsock/virtio: free packets during the socket release&quot;), but we\nforgot to drain the RX queue when the socket is definitely closed by\nthe scheduled work.\r\n\r\nTo avoid future issues, let&apos;s use the new virtio_transport_remove_sock()\nto drain the RX queue before removing the socket from the af_vsock lists\ncalling vsock_remove_sock().\r\n\r\n[1] https://syzkaller.appspot.com/bug?extid=24452624fc4c571eedd9(CVE-2021-47024)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nio_uring: fix overflows checks in provide buffers\r\n\r\nColin reported before possible overflow and sign extension problems in\nio_provide_buffers_prep(). As Linus pointed out previous attempt did nothing\nuseful, see d81269fecb8ce (&quot;io_uring: fix provide_buffers sign extension&quot;).\r\n\r\nDo that with help of check_&lt;op&gt;_overflow helpers. And fix struct\nio_provide_buf::len type, as it doesn&apos;t make much sense to keep it\nsigned.(CVE-2021-47040)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nDrivers: hv: vmbus: Use after free in __vmbus_open()\r\n\r\nThe &quot;open_info&quot; variable is added to the &amp;vmbus_connection.chn_msg_list,\nbut the error handling frees &quot;open_info&quot; without removing it from the\nlist.  This will result in a use after free.  First remove it from the\nlist, and then free it.(CVE-2021-47049)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nblock: add check that partition length needs to be aligned with block size\r\n\r\nBefore calling add partition or resize partition, there is no check\non whether the length is aligned with the logical block size.\nIf the logical block size of the disk is larger than 512 bytes,\nthen the partition size maybe not the multiple of the logical block size,\nand when the last sector is read, bio_truncate() will adjust the bio size,\nresulting in an IO error if the size of the read command is smaller than\nthe logical block size.If integrity data is supported, this will also\nresult in a null pointer dereference when calling bio_integrity_free.(CVE-2023-52458)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nnet: usb: smsc75xx: Fix uninit-value access in __smsc75xx_read_reg\r\n\r\nsyzbot reported the following uninit-value access issue:\r\n\r\n=====================================================\nBUG: KMSAN: uninit-value in smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:975 [inline]\nBUG: KMSAN: uninit-value in smsc75xx_bind+0x5c9/0x11e0 drivers/net/usb/smsc75xx.c:1482\nCPU: 0 PID: 8696 Comm: kworker/0:3 Not tainted 5.8.0-rc5-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011\nWorkqueue: usb_hub_wq hub_event\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x21c/0x280 lib/dump_stack.c:118\n kmsan_report+0xf7/0x1e0 mm/kmsan/kmsan_report.c:121\n __msan_warning+0x58/0xa0 mm/kmsan/kmsan_instr.c:215\n smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:975 [inline]\n smsc75xx_bind+0x5c9/0x11e0 drivers/net/usb/smsc75xx.c:1482\n usbnet_probe+0x1152/0x3f90 drivers/net/usb/usbnet.c:1737\n usb_probe_interface+0xece/0x1550 drivers/usb/core/driver.c:374\n really_probe+0xf20/0x20b0 drivers/base/dd.c:529\n driver_probe_device+0x293/0x390 drivers/base/dd.c:701\n __device_attach_driver+0x63f/0x830 drivers/base/dd.c:807\n bus_for_each_drv+0x2ca/0x3f0 drivers/base/bus.c:431\n __device_attach+0x4e2/0x7f0 drivers/base/dd.c:873\n device_initial_probe+0x4a/0x60 drivers/base/dd.c:920\n bus_probe_device+0x177/0x3d0 drivers/base/bus.c:491\n device_add+0x3b0e/0x40d0 drivers/base/core.c:2680\n usb_set_configuration+0x380f/0x3f10 drivers/usb/core/message.c:2032\n usb_generic_driver_probe+0x138/0x300 drivers/usb/core/generic.c:241\n usb_probe_device+0x311/0x490 drivers/usb/core/driver.c:272\n really_probe+0xf20/0x20b0 drivers/base/dd.c:529\n driver_probe_device+0x293/0x390 drivers/base/dd.c:701\n __device_attach_driver+0x63f/0x830 drivers/base/dd.c:807\n bus_for_each_drv+0x2ca/0x3f0 drivers/base/bus.c:431\n __device_attach+0x4e2/0x7f0 drivers/base/dd.c:873\n device_initial_probe+0x4a/0x60 drivers/base/dd.c:920\n bus_probe_device+0x177/0x3d0 drivers/base/bus.c:491\n device_add+0x3b0e/0x40d0 drivers/base/core.c:2680\n usb_new_device+0x1bd4/0x2a30 drivers/usb/core/hub.c:2554\n hub_port_connect drivers/usb/core/hub.c:5208 [inline]\n hub_port_connect_change drivers/usb/core/hub.c:5348 [inline]\n port_event drivers/usb/core/hub.c:5494 [inline]\n hub_event+0x5e7b/0x8a70 drivers/usb/core/hub.c:5576\n process_one_work+0x1688/0x2140 kernel/workqueue.c:2269\n worker_thread+0x10bc/0x2730 kernel/workqueue.c:2415\n kthread+0x551/0x590 kernel/kthread.c:292\n ret_from_fork+0x1f/0x30 arch/x86/entry/entry_64.S:293\r\n\r\nLocal variable ----buf.i87@smsc75xx_bind created at:\n __smsc75xx_read_reg drivers/net/usb/smsc75xx.c:83 [inline]\n smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:968 [inline]\n smsc75xx_bind+0x485/0x11e0 drivers/net/usb/smsc75xx.c:1482\n __smsc75xx_read_reg drivers/net/usb/smsc75xx.c:83 [inline]\n smsc75xx_wait_ready drivers/net/usb/smsc75xx.c:968 [inline]\n smsc75xx_bind+0x485/0x11e0 drivers/net/usb/smsc75xx.c:1482\r\n\r\nThis issue is caused because usbnet_read_cmd() reads less bytes than requested\n(zero byte in the reproducer). In this case, &apos;buf&apos; is not properly filled.\r\n\r\nThis patch fixes the issue by returning -ENODATA if usbnet_read_cmd() reads\nless bytes than requested.(CVE-2023-52528)\r\n\r\nIn the Linux kernel, the following vulnerability has been resolved:\r\n\r\nFS:JFS:UBSAN:array-index-out-of-bounds in dbAdjTree\r\n\r\nSyzkaller reported the following issue:\r\n\r\nUBSAN: array-index-out-of-bounds in fs/jfs/jfs_dmap.c:2867:6\nindex 196694 is out of range for type &apos;s8[1365]&apos; (aka &apos;signed char[1365]&apos;)\nCPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023\nCall Trace:\n &lt;TASK&gt;\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106\n ubsan_epilogue lib/ubsan.c:217 [inline]\n __ubsan_handle_out_of_bounds+0x11c/0x150 lib/ubsan.c:348\n dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867\n dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834\n dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331\n dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]\n dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402\n txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534\n txUpdateMap+0x342/0x9e0\n txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]\n jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732\n kthread+0x2d3/0x370 kernel/kthread.c:388\n ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304\n &lt;/TASK&gt;\n================================================================================\nKernel panic - not syncing: UBSAN: panic_on_warn set ...\nCPU: 1 PID: 109 Comm: jfsCommit Not tainted 6.6.0-rc3-syzkaller #0\nHardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 08/04/2023\nCall Trace:\n &lt;TASK&gt;\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x1e7/0x2d0 lib/dump_stack.c:106\n panic+0x30f/0x770 kernel/panic.c:340\n check_panic_on_warn+0x82/0xa0 kernel/panic.c:236\n ubsan_epilogue lib/ubsan.c:223 [inline]\n __ubsan_handle_out_of_bounds+0x13c/0x150 lib/ubsan.c:348\n dbAdjTree+0x474/0x4f0 fs/jfs/jfs_dmap.c:2867\n dbJoin+0x210/0x2d0 fs/jfs/jfs_dmap.c:2834\n dbFreeBits+0x4eb/0xda0 fs/jfs/jfs_dmap.c:2331\n dbFreeDmap fs/jfs/jfs_dmap.c:2080 [inline]\n dbFree+0x343/0x650 fs/jfs/jfs_dmap.c:402\n txFreeMap+0x798/0xd50 fs/jfs/jfs_txnmgr.c:2534\n txUpdateMap+0x342/0x9e0\n txLazyCommit fs/jfs/jfs_txnmgr.c:2664 [inline]\n jfs_lazycommit+0x47a/0xb70 fs/jfs/jfs_txnmgr.c:2732\n kthread+0x2d3/0x370 kernel/kthread.c:388\n ret_from_fork+0x48/0x80 arch/x86/kernel/process.c:147\n ret_from_fork_asm+0x11/0x20 arch/x86/entry/entry_64.S:304\n &lt;/TASK&gt;\nKernel Offset: disabled\nRebooting in 86400 seconds..\r\n\r\nThe issue is caused when the value of lp becomes greater than\nCTLTREESIZE which is the max size of stree. Adding a simple check\nsolves this issue.\r\n\r\nDave:\nAs the function returns a void, good error handling\nwould require a more intrusive code reorganization, so I modified\nOsama&apos;s patch at use WARN_ON_ONCE for lack of a cleaner option.\r\n\r\nThe patch is tested via syzbot.(CVE-2023-52604)","affected":[{"package":{"name":"kernel","ecosystem":"openEuler:20.03-LTS-SP1","purl":"pkg:rpm/openEuler/kernel&distro=openEuler-20.03-LTS-SP1"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"0"},{"fixed":"4.19.90-2403.3.0.0244.oe1"}]}],"ecosystem_specific":{"aarch64":["kernel-source-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","perf-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","bpftool-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","python3-perf-debuginfo-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","kernel-debugsource-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","kernel-tools-devel-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","kernel-debuginfo-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","kernel-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","kernel-tools-debuginfo-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","bpftool-debuginfo-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","python2-perf-debuginfo-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","python3-perf-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","kernel-devel-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","python2-perf-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","perf-debuginfo-4.19.90-2403.3.0.0244.oe1.aarch64.rpm","kernel-tools-4.19.90-2403.3.0.0244.oe1.aarch64.rpm"],"src":["kernel-4.19.90-2403.3.0.0244.oe1.src.rpm"],"x86_64":["kernel-tools-debuginfo-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","kernel-devel-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","perf-debuginfo-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","python2-perf-debuginfo-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","perf-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","kernel-debuginfo-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","python2-perf-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","kernel-tools-devel-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","bpftool-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","kernel-debugsource-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","python3-perf-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","python3-perf-debuginfo-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","kernel-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","bpftool-debuginfo-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","kernel-tools-4.19.90-2403.3.0.0244.oe1.x86_64.rpm","kernel-source-4.19.90-2403.3.0.0244.oe1.x86_64.rpm"]},"database_specific":{"source":"https://repo.openeuler.org/security/data/osv/OESA-2024-1345.json"}}],"references":[{"type":"ADVISORY","url":"https://www.openeuler.org/en/security/safety-bulletin/detail.html?id=openEuler-SA-2024-1345"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2020-36778"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2020-36782"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-46906"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-46909"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-46941"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-46955"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-46998"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47006"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47013"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47015"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47024"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47040"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2021-47049"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-52458"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-52528"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2023-52604"}],"database_specific":{"severity":"High"}}