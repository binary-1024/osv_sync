{"schema_version":"1.7.3","id":"CVE-2026-22981","published":"2026-01-23T15:24:03.772Z","modified":"2026-01-23T19:59:27.968375Z","summary":"idpf: detach and close netdevs while handling a reset","details":"In the Linux kernel, the following vulnerability has been resolved:\n\nidpf: detach and close netdevs while handling a reset\n\nProtect the reset path from callbacks by setting the netdevs to detached\nstate and close any netdevs in UP state until the reset handling has\ncompleted. During a reset, the driver will de-allocate resources for the\nvport, and there is no guarantee that those will recover, which is why the\nexisting vport_ctrl_lock does not provide sufficient protection.\n\nidpf_detach_and_close() is called right before reset handling. If the\nreset handling succeeds, the netdevs state is recovered via call to\nidpf_attach_and_open(). If the reset handling fails the netdevs remain\ndown. The detach/down calls are protected with RTNL lock to avoid racing\nwith callbacks. On the recovery side the attach can be done without\nholding the RTNL lock as there are no callbacks expected at that point,\ndue to detach/close always being done first in that flow.\n\nThe previous logic restoring the netdevs state based on the\nIDPF_VPORT_UP_REQUESTED flag in the init task is not needed anymore, hence\nthe removal of idpf_set_vport_state(). The IDPF_VPORT_UP_REQUESTED is\nstill being used to restore the state of the netdevs following the reset,\nbut has no use outside of the reset handling flow.\n\nidpf_init_hard_reset() is converted to void, since it was used as such and\nthere is no error handling being done based on its return value.\n\nBefore this change, invoking hard and soft resets simultaneously will\ncause the driver to lose the vport state:\nip -br a\n<inf>\tUP\necho 1 > /sys/class/net/ens801f0/device/reset& \\\nethtool -L ens801f0 combined 8\nip -br a\n<inf>\tDOWN\nip link set <inf> up\nip -br a\n<inf>\tDOWN\n\nAlso in case of a failure in the reset path, the netdev is left\nexposed to external callbacks, while vport resources are not\ninitialized, leading to a crash on subsequent ifup/down:\n[408471.398966] idpf 0000:83:00.0: HW reset detected\n[408471.411744] idpf 0000:83:00.0: Device HW Reset initiated\n[408472.277901] idpf 0000:83:00.0: The driver was unable to contact the device's firmware. Check that the FW is running. Driver state= 0x2\n[408508.125551] BUG: kernel NULL pointer dereference, address: 0000000000000078\n[408508.126112] #PF: supervisor read access in kernel mode\n[408508.126687] #PF: error_code(0x0000) - not-present page\n[408508.127256] PGD 2aae2f067 P4D 0\n[408508.127824] Oops: Oops: 0000 [#1] SMP NOPTI\n...\n[408508.130871] RIP: 0010:idpf_stop+0x39/0x70 [idpf]\n...\n[408508.139193] Call Trace:\n[408508.139637]  <TASK>\n[408508.140077]  __dev_close_many+0xbb/0x260\n[408508.140533]  __dev_change_flags+0x1cf/0x280\n[408508.140987]  netif_change_flags+0x26/0x70\n[408508.141434]  dev_change_flags+0x3d/0xb0\n[408508.141878]  devinet_ioctl+0x460/0x890\n[408508.142321]  inet_ioctl+0x18e/0x1d0\n[408508.142762]  ? _copy_to_user+0x22/0x70\n[408508.143207]  sock_do_ioctl+0x3d/0xe0\n[408508.143652]  sock_ioctl+0x10e/0x330\n[408508.144091]  ? find_held_lock+0x2b/0x80\n[408508.144537]  __x64_sys_ioctl+0x96/0xe0\n[408508.144979]  do_syscall_64+0x79/0x3d0\n[408508.145415]  entry_SYSCALL_64_after_hwframe+0x76/0x7e\n[408508.145860] RIP: 0033:0x7f3e0bb4caff","affected":[{"ranges":[{"type":"GIT","repo":"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git","events":[{"introduced":"0fe45467a1041ea3657a7fa3a791c84c104fbd34"},{"fixed":"ac122f5fb050903b3d262001562c452be95eaf70"},{"fixed":"2e281e1155fc476c571c0bd2ffbfe28ab829a5c3"}]}],"versions":["v6.10","v6.10-rc1","v6.10-rc2","v6.10-rc3","v6.10-rc4","v6.10-rc5","v6.10-rc6","v6.10-rc7","v6.11","v6.11-rc1","v6.11-rc2","v6.11-rc3","v6.11-rc4","v6.11-rc5","v6.11-rc6","v6.11-rc7","v6.12","v6.12-rc1","v6.12-rc2","v6.12-rc3","v6.12-rc4","v6.12-rc5","v6.12-rc6","v6.12-rc7","v6.13","v6.13-rc1","v6.13-rc2","v6.13-rc3","v6.13-rc4","v6.13-rc5","v6.13-rc6","v6.13-rc7","v6.14","v6.14-rc1","v6.14-rc2","v6.14-rc3","v6.14-rc4","v6.14-rc5","v6.14-rc6","v6.14-rc7","v6.15","v6.15-rc1","v6.15-rc2","v6.15-rc3","v6.15-rc4","v6.15-rc5","v6.15-rc6","v6.15-rc7","v6.16","v6.16-rc1","v6.16-rc2","v6.16-rc3","v6.16-rc4","v6.16-rc5","v6.16-rc6","v6.16-rc7","v6.17","v6.17-rc1","v6.17-rc2","v6.17-rc3","v6.17-rc4","v6.17-rc5","v6.17-rc6","v6.17-rc7","v6.18","v6.18-rc1","v6.18-rc2","v6.18-rc3","v6.18-rc4","v6.18-rc5","v6.18-rc6","v6.18-rc7","v6.18.1","v6.18.2","v6.18.3","v6.18.4","v6.18.5","v6.19-rc1","v6.19-rc2","v6.19-rc3","v6.6","v6.6-rc1","v6.6-rc2","v6.6-rc3","v6.6-rc4","v6.6-rc5","v6.6-rc6","v6.6-rc7","v6.7","v6.7-rc1","v6.7-rc2","v6.7-rc3","v6.7-rc4","v6.7-rc5","v6.7-rc6","v6.7-rc7","v6.7-rc8","v6.8","v6.8-rc1","v6.8-rc2","v6.8-rc3","v6.8-rc4","v6.8-rc5","v6.8-rc6","v6.8-rc7","v6.9","v6.9-rc1","v6.9-rc2","v6.9-rc3","v6.9-rc4","v6.9-rc5","v6.9-rc6","v6.9-rc7"],"database_specific":{"source":"https://storage.googleapis.com/cve-osv-conversion/osv-output/CVE-2026-22981.json"}},{"package":{"name":"Kernel","ecosystem":"Linux"},"ranges":[{"type":"ECOSYSTEM","events":[{"introduced":"6.7.0"},{"fixed":"6.18.6"}]}],"database_specific":{"source":"https://storage.googleapis.com/cve-osv-conversion/osv-output/CVE-2026-22981.json"}}],"references":[{"type":"PACKAGE","url":"https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git"},{"type":"WEB","url":"https://git.kernel.org/stable/c/2e281e1155fc476c571c0bd2ffbfe28ab829a5c3"},{"type":"WEB","url":"https://git.kernel.org/stable/c/ac122f5fb050903b3d262001562c452be95eaf70"},{"type":"ADVISORY","url":"https://github.com/CVEProject/cvelistV5/tree/main/cves/2026/22xxx/CVE-2026-22981.json"},{"type":"ADVISORY","url":"https://nvd.nist.gov/vuln/detail/CVE-2026-22981"}],"database_specific":{"cna_assigner":"Linux","osv_generated_from":"https://github.com/CVEProject/cvelistV5/tree/main/cves/2026/22xxx/CVE-2026-22981.json"}}